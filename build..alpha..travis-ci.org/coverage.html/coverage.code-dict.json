{"/home/travis/build/npmtest/node-npmtest-jspm/test.js":"/* istanbul instrument in package npmtest_jspm */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-jspm/lib.npmtest_jspm.js":"/* istanbul instrument in package npmtest_jspm */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_jspm = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_jspm = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-jspm/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-jspm && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_jspm */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_jspm\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_jspm.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_jspm.rollup.js'] =\n            local.assetsDict['/assets.npmtest_jspm.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_jspm.__dirname + '/lib.npmtest_jspm.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-jspm/node_modules/jspm/api.js":"/*\n *   Copyright 2014-2015 Guy Bedford (http://guybedford.com)\n *\n *   Licensed under the Apache License, Version 2.0 (the \"License\");\n *   you may not use this file except in compliance with the License.\n *   You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n *   Unless required by applicable law or agreed to in writing, software\n *   distributed under the License is distributed on an \"AS IS\" BASIS,\n *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *   See the License for the specific language governing permissions and\n *   limitations under the License.\n */\n\nvar install = require('./lib/install');\nvar bundle = require('./lib/bundle');\nvar core = require('./lib/core');\nvar ui = require('./lib/ui');\nvar EventEmitter = require('events').EventEmitter;\nvar SystemJSLoader = require('systemjs').constructor;\nvar config = require('./lib/config');\nvar path = require('path');\nvar toFileURL = require('./lib/common').toFileURL;\n\nrequire('rsvp').on('error', function(reason) {\n  ui.log('warn', 'Unhandled promise rejection.\\n' + reason && reason.stack || reason || '' + '\\n');\n});\n\nvar API = module.exports = new EventEmitter();\n\nAPI.setPackagePath = function(packagePath) {\n  if (config.loaded && process.env.jspmConfigPath !== path.resolve(packagePath, 'package.json'))\n    throw new Error('Configuration has already been loaded. Call setPackagePath before using other APIs.');\n  process.env.jspmConfigPath = path.resolve(packagePath, 'package.json');\n};\nAPI.setPackagePath('.');\n\n/*\n * jspm.on('log', function(type, msg) { console.log(msg); });\n * jspm.on('prompt', function(prompt, callback) {\n *   if (prompt.type == 'confirm')\n *     callback({ confirm: true });\n *   if (prompt.type == 'input')\n *     callback({ input: value });\n * });\n *\n * Prompt as defined in https://github.com/SBoudrias/Inquirer.js/tree/master#question\n * Callback answer defined in https://github.com/SBoudrias/Inquirer.js/tree/master#answers\n */\nui.setResolver(API);\nui.useDefaults();\n\nAPI.promptDefaults = function(_useDefaults) {\n  ui.useDefaults(_useDefaults);\n};\n\nAPI.version = require('./package.json').version;\n\n/*\n * Loader API\n */\n\nvar apiLoader;\nAPI.normalize = function(name, parentName) {\n  apiLoader = apiLoader || new API.Loader();\n  return apiLoader.normalize(name, parentName);\n};\n\nAPI.import = function(name, parentName) {\n  apiLoader = apiLoader || new API.Loader();\n  return apiLoader.import(name, parentName);\n};\n\nAPI.Loader = function() {\n  config.loadSync();\n\n  var cfg = config.loader.getConfig();\n  cfg.baseURL = toFileURL(config.pjson.baseURL);\n\n  var loader = new SystemJSLoader();\n  loader.config(cfg);\n\n  return loader;\n};\n\n/*\n * Builder API\n */\nAPI.Builder = bundle.Builder;\n\n// options.inject\n// options.sourceMaps\n// options.minify\nAPI.bundle = function(expression, fileName, options) {\n  return bundle.bundle(expression, fileName, options);\n};\n\n/*\n * Remove the bundle configuration.\n * This will allow you to move back to separate file mode\n * returns a promise\n */\nAPI.unbundle = function() {\n  return bundle.unbundle();\n};\n\n\n/*\n * Creates a distributable script file that can be used entirely on its own independent of SystemJS and jspm.\n * returns a promise\n * options.minify, options.sourceMaps\n */\nAPI.bundleSFX = function(expression, fileName, options) {\n  return bundle.bundleSFX(expression, fileName, options);\n};\n\n\n/*\n * Package Management API\n *\n\n/*\n * Installs a library in the current folder\n * returns a promise\n *\n * jspm.install('jquery')\n * jspm.install('jquery', 'github:components/jquery@^2.0.0')\n * jspm.install('jquery', '2')\n * jspm.install('jquery', 'github:components/jquery')\n * jspm.install('jquery', { force: true });\n * jspm.install({ jquery: '1.2.3' }, { force: true })\n * jspm.install(true, options) // install from package.json\n *\n */\nAPI.install = function(name, target, options) {\n  return install.install(name, target, options);\n};\n\n/* Uninstalls a library in the current folder.\n * returns a promise\n *\n * jspm.uninstall('jquery')\n * jspm.uninstall(['jquery', 'handlebars'])\n *\n */\nAPI.uninstall = function(names) {\n  return install.uninstall(names);\n};\n\nAPI.dlLoader = function(transpiler) {\n  return core.checkDlLoader(transpiler);\n};\n","/home/travis/build/npmtest/node-npmtest-jspm/node_modules/jspm/lib/install.js":"/*\n *   Copyright 2014-2015 Guy Bedford (http://guybedford.com)\n *\n *   Licensed under the Apache License, Version 2.0 (the \"License\");\n *   you may not use this file except in compliance with the License.\n *   You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n *   Unless required by applicable law or agreed to in writing, software\n *   distributed under the License is distributed on an \"AS IS\" BASIS,\n *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *   See the License for the specific language governing permissions and\n *   limitations under the License.\n */\n\nrequire('core-js/es6/string');\n\nvar config = require('./config');\nvar Promise = require('rsvp').Promise;\nvar asp = require('rsvp').denodeify;\nvar pkg = require('./package');\nvar semver = require('./semver');\nvar PackageName = require('./config/package-name');\nvar ui = require('./ui');\nvar path = require('path');\nvar link = require('./link');\nvar globalConfig = require('./global-config');\n\nvar rimraf = require('rimraf');\n\nvar alphabetize = require('./common').alphabetize;\nvar cascadeDelete = require('./common').cascadeDelete;\nvar hasProperties = require('./common').hasProperties;\n\nvar fs = require('graceful-fs');\n\nvar primaryRanges = {};\nvar secondaryRanges = {};\n\nvar installedResolves = {};\nvar installingResolves = {};\n\nvar installed;\nvar installing = {\n  baseMap: {},\n  depMap: {}\n};\n\n// NB remove assertions for release\n// function assert(statement, name) {\n//  if (!statement)\n//    throw new TypeError('Assertion Failed: ' + name);\n// }\n\n/*\n * Main install API wrapper\n *\n * install('jquery')\n * install('jquery', {options})\n * install('jquery', 'github:components/jquery')\n * install('jquery', 'github:components/jquery', {options})\n * install(true) - from package.json\n * install(true, {options}) - from package.json\n *\n * options.force - skip cache\n * options.inject\n * options.link means symlink linked versions in ranges to jspm_packages where available\n * options.lock - lock existing tree dependencies\n * options.latest - new install tree has all deps installed to latest - no rollback deduping\n * options.unlink\n * options.quick - lock and skip hash checks\n * options.dev - store in devDependencies\n * options.production - only install dependencies, not devDependencies\n * options.update - we're updating the targets\n *\n * options.summary - show fork and resolution summary\n */\nexports.install = function(targets, options) {\n  if (typeof targets === 'string') {\n    var name = targets;\n    targets = {};\n    targets[name] = typeof options === 'string' ? options : '';\n    options = typeof options === 'object' ? options : arguments[2];\n  }\n  options = options || {};\n\n  return config.load()\n  .then(function() {\n    installed = installed || config.loader;\n\n    if (options.force)\n      config.force = true;\n\n    if (options.link || options.quick)\n      options.lock = true;\n\n    var d, existingTargets = {};\n\n    if (!options.production) {\n      for (d in config.pjson.devDependencies)\n        existingTargets[d] = config.pjson.devDependencies[d];\n    }\n\n    for (d in config.pjson.dependencies)\n      existingTargets[d] = config.pjson.dependencies[d];\n\n    if (targets === true)\n      targets = existingTargets;\n    // check and set targets for update\n    else if (targets && options.update)\n      for (d in targets) {\n        if (!existingTargets[d])\n          throw '%' + d + '% is not an existing dependency to update.';\n        targets[d] = existingTargets[d];\n      }\n\n    targets = pkg.processDeps(targets, globalConfig.config.defaultRegistry);\n\n    return Promise.all(Object.keys(targets).map(function(name) {\n      return install(name, targets[name], options);\n    }))\n    .then(function() {\n      return saveInstall();\n    })\n    .then(function() {\n      // after every install, show fork and resolution summary\n      if (options.summary !== false)\n        showVersions(true);\n    });\n  });\n};\n\n/*\n * install('jquery', 'jquery', { latest, lock, parent, inject, link, unlink, override } [, seen])\n *\n * Install modes:\n *  - Default  a. The new install tree is set to use exact latest versions of primaries,\n *                including for existing primaries.\n *                Secondaries tend to their latest ideal version.\n *             b. Forks within the new tree are deduped for secondaries by checking for\n *                rollback of the higher version.\n *             c. Forks against the existing tree are handled by upgrading the existing\n *                tree, at both primary and secondary levels, with the secondary fork\n *                potentially rolling back as well.\n *             (this is `jspm install package`)\n *\n *  - Lock     No existing dependencies are altered.\n *             New installs otherwise follow default behaviour for secondary deduping.\n *             (this is reproducible installs, `jspm install` without arguments)\n *\n *  - Latest   Secondaries set exactly to latest.\n *             Forks against existing tree follow default behaviour.\n *             (this is `jspm update`)\n *\n * Lock and Latest can be combined, which won't do anything for existing\n * installs but will give latest secondaries on new installs.\n *\n * Secondary installs are those with a parent.\n *\n * Seen allows correct completion with circular package installs\n *\n */\n\n/*\n * jspm.install('jquery')\n * jspm.install('jquery', 'github:components/jquery@^2.0.0')\n * jspm.install('jquery', '2')\n * jspm.install('jquery', 'github:components/jquery')\n * jspm.install('jquery', { force: true });\n * jspm.install({ jquery: '1.2.3' }, { force: true })\n */\nfunction install(name, target, options, seen) {\n  // we install a target range, to an exact version resolution\n  var resolution;\n  var dependencyDownloads;\n  var existing;\n\n  return Promise.resolve()\n  .then(function() {\n    if (options.link)\n      return Promise.resolve(target);\n\n    return pkg.locate(target);\n  })\n  .then(function(located) {\n    target = located;\n\n    config.loader.ensureRegistry(located.registry, options.inject);\n\n    if (options.link)\n      return link.lookup(target, options.edge);\n\n    // lock if necessary\n    if (options.lock && (resolution = getInstalledMatch(target, options.parent, name)))\n      return Promise.resolve();\n\n    // perform a full version lookup\n    return pkg.lookup(target, options.edge);\n  })\n  .then(function(getLatestMatch) {\n    if (!getLatestMatch)\n      return storeResolution();\n\n    // --- version constraint solving ---\n\n    // a. The new install tree is set to use exact latest versions of primaries, including for existing primaries.\n    //    Secondaries tend to their latest ideal version.\n    resolution = getLatestMatch(target.version);\n\n    if (!resolution) {\n      if (options.parent)\n        throw 'Installing `' + options.parent + '`, no version match for `' + target.exactName + '`';\n      else\n        throw 'No version match found for `' + target.exactName + '`';\n    }\n\n    // if no version range was specified on install, install to semver-compatible with the latest\n    if (!options.parent && !target.version && !options.link) {\n      if (resolution.version.match(semver.semverRegEx))\n        target.setVersion('^' + resolution.version);\n      else\n        target.setVersion(resolution.version);\n    }\n    else if (options.edge && !options.parent && !options.link) {\n      // use strictest compatible semver range if installing --edge without target, or\n      // with a range that does not include the resolved version\n      if (!target.version || !semver.match(target.version, resolution.version)) {\n        target.setVersion('^' + resolution.version);\n      }\n    }\n\n    // load our fork ranges to do a resolution\n    return loadExistingForkRanges(resolution, name, options.parent, options.inject)\n    .then(function() {\n      // here, alter means upgrade or rollback\n\n      // if we've consolidated with another resolution, we don't do altering\n      var consolidated = false;\n\n      // b. Forks within the new tree are deduped for secondaries by checking for rollback of the higher version\n      if (!options.latest)\n        resolveForks(installing, name, options.parent, resolution, function(forkVersion, forkRanges, allSecondary) {\n          // alter the other secondaries to this primary or secondary\n          if (allSecondary && forkRanges.every(function(forkRange) {\n            return semver.match(forkRange, resolution.version);\n          })) {\n            consolidated = true;\n            return resolution.version;\n          }\n\n          // alter this secondary install to the other primary or secondary\n          if (!consolidated && options.parent && semver.match(target.version, forkVersion)) {\n            consolidated = true;\n            if (forkVersion !== resolution.version) {\n              var newResolution = resolution.copy().setVersion(forkVersion);\n              logResolution(installingResolves, resolution, newResolution);\n              resolution = newResolution;\n            }\n          }\n        });\n\n      // c. Forks against the existing tree are handled by upgrading the existing tree,\n      //    at both primary and secondary levels, with the secondary fork potentially rolling back as well.\n      resolveForks(installed, name, options.parent, resolution, function(forkVersion, forkRanges) {\n        if (options.latest && semver.compare(forkVersion, resolution.version) === 1)\n          return;\n\n        if (forkRanges.every(function(forkRange) {\n          return semver.match(forkRange, resolution.version);\n        })) {\n          consolidated = true;\n          return resolution.version;\n        }\n\n        // find the best upgrade of all the fork ranges for rollback of secondaries\n        if (!consolidated && options.parent && !options.latest) {\n          var bestSecondaryRollback = resolution;\n          forkRanges.forEach(function(forkRange) {\n            var forkLatest = getLatestMatch(forkRange);\n            if (semver.compare(bestSecondaryRollback.version, forkLatest.version) === 1)\n              bestSecondaryRollback = forkLatest;\n          });\n\n          if (semver.compare(bestSecondaryRollback.version, forkVersion) === -1)\n            bestSecondaryRollback = getLatestMatch(forkVersion);\n\n          if (semver.match(target.version, bestSecondaryRollback.version)) {\n            consolidated = true;\n            logResolution(installingResolves, resolution, bestSecondaryRollback);\n            resolution = bestSecondaryRollback;\n            return bestSecondaryRollback.version;\n          }\n        }\n      });\n\n      // solve and save resolution solution synchronously - this lock avoids solution conflicts\n      storeResolution();\n    });\n  })\n  .then(function() {\n\n    // -- handle circular installs --\n\n    seen = seen || [];\n    if (seen.indexOf(resolution.exactName) !== -1)\n      return;\n    seen.push(resolution.exactName);\n\n    // allow custom resolutions\n    if (!resolution.registry)\n      return;\n\n    // -- download --\n    return Promise.resolve()\n    .then(function() {\n      if (options.link)\n        return link.symlink(resolution, downloadDeps);\n\n      if (options.inject)\n        return pkg.inject(resolution, downloadDeps);\n\n      // override, quick, unlink options passed\n      return pkg.download(resolution, options, downloadDeps);\n    })\n    .then(function(fresh) {\n      resolution.fresh = fresh;\n      // log sub-dependencies before child completion for nicer output\n      if (options.parent)\n        logInstall(name, target, resolution, options);\n\n      return dependencyDownloads;\n    })\n    .then(function() {\n      if (!options.parent)\n        logInstall(name, target, resolution, options);\n    });\n  });\n\n  // store resolution in config\n  function storeResolution() {\n    var curMap;\n    if (options.parent) {\n      curMap = (existing ? installed : installing).depMap;\n      curMap[options.parent] = curMap[options.parent] || {};\n      curMap[options.parent][name] = resolution.copy();\n    }\n    else {\n      curMap = (existing ? installed : installing).baseMap;\n      curMap[name] = resolution.copy();\n    }\n\n    // update the dependency range tree\n    if (!options.parent) {\n      if (!primaryRanges[name] || primaryRanges[name].exactName !== target.exactName)\n        primaryRanges[name] = target.copy();\n      // store in package.json\n      if (!options.link) {\n        if (name in config.pjson.dependencies)\n          config.pjson.dependencies[name] = primaryRanges[name];\n        else if (name in config.pjson.devDependencies)\n          config.pjson.devDependencies[name] = primaryRanges[name];\n        else if (!options.dev) {\n          config.pjson.dependencies[name] = primaryRanges[name];\n        }\n        else {\n          config.pjson.devDependencies[name] = primaryRanges[name];\n        }\n\n        if (options.override)\n          config.pjson.overrides[resolution.exactName] = options.override;\n      }\n    }\n    else {\n      // update the secondary ranges\n      secondaryRanges[options.parent] = secondaryRanges[options.parent] || {};\n      if (!secondaryRanges[options.parent][name])\n        secondaryRanges[options.parent][name] = target.copy();\n      else\n        if (secondaryRanges[options.parent][name] && secondaryRanges[options.parent][name].exactName !== target.exactName)\n          ui.log('warn', 'Currently installed dependency ranges of `' + options.parent + '` are not consistent ( %' + secondaryRanges[options.parent][name].exactName + '% should be %' + target.exactName + '%)');\n    }\n  }\n\n  // trigger dependency downloads\n  // this can be triggered twice\n  //  - once by initial preload, and once post-build if additional dependencies are discovered\n  function downloadDeps(depMap) {\n    // clear existing dependencies on first run for existing installs\n    if (!dependencyDownloads && existing)\n      installed.depMap[resolution.exactName] = {};\n\n    dependencyDownloads = (dependencyDownloads || Promise.resolve()).then(function() {\n      return Promise.all(Object.keys(depMap).map(function(dep) {\n        return install(dep, depMap[dep], {\n          latest: options.latest,\n          lock: options.lock,\n          parent: resolution.exactName,\n          inject: options.inject,\n          quick: options.quick\n        }, seen);\n      }));\n    });\n  }\n}\n\nfunction getInstalledMatch(target, parent, name) {\n  // use the config lock if provided\n  if (parent) {\n    if (installed.depMap[parent] && installed.depMap[parent][name])\n      return installed.depMap[parent][name];\n  }\n  else {\n    if (installed.baseMap[name])\n      return installed.baseMap[name];\n  }\n\n  // otherwise seek an installed match\n  var match;\n  function checkMatch(pkg) {\n    if (pkg.name !== target.name)\n      return;\n    if (semver.match(target.version, pkg.version)) {\n      if (!match || match && semver.compare(pkg.version, match.version) === 1)\n        match = pkg.copy();\n    }\n  }\n  Object.keys(installed.baseMap).forEach(function(name) {\n    checkMatch(installed.baseMap[name]);\n  });\n  Object.keys(installed.depMap).forEach(function(parent) {\n    var depMap = installed.depMap[parent];\n    Object.keys(depMap).forEach(function(name) {\n      checkMatch(depMap[name]);\n    });\n  });\n  return match;\n}\n\nfunction saveInstall() {\n  return Promise.resolve()\n  .then(function() {\n\n    // merge the installing tree into the installed\n    Object.keys(installing.baseMap).forEach(function(p) {\n      installed.baseMap[p] = installing.baseMap[p];\n    });\n\n    Object.keys(installing.depMap).forEach(function(p) {\n      installed.depMap[p] = installing.depMap[p];\n    });\n\n    return clean();\n  })\n  .then(function() {\n    if (hasProperties(installedResolves)) {\n      ui.log('');\n      ui.log('info', 'The following existing package versions were altered by install deduping:');\n      ui.log('');\n      Object.keys(installedResolves).forEach(function(pkg) {\n        var pkgName = new PackageName(pkg);\n        ui.log('info', '  %' + pkgName.package + '% ' + getUpdateRangeText(pkgName, new PackageName(installedResolves[pkg])));\n      });\n      ui.log('');\n      installedResolves = {};\n      ui.log('info', 'To keep existing dependencies locked during install, use the %--lock% option.');\n    }\n\n    if (hasProperties(installingResolves)) {\n      ui.log('');\n      ui.log('info', 'The following new package versions were substituted by install deduping:');\n      ui.log('');\n      Object.keys(installingResolves).forEach(function(pkg) {\n        var pkgName = new PackageName(pkg);\n        ui.log('info', '  %' + pkgName.package + '% ' + getUpdateRangeText(pkgName, new PackageName(installingResolves[pkg])));\n      });\n      ui.log('') ;\n      installingResolves = {};\n    }\n\n    // then save\n    return config.save();\n  });\n}\n\nvar logged = {};\nfunction logInstall(name, target, resolution, options) {\n  if (logged[target.exactName + '=' + resolution.exactName])\n    return;\n\n  // don't log secondary fresh\n  if (options.parent && resolution.fresh)\n    return;\n\n  logged[target.exactName + '=' + resolution.exactName] = true;\n\n  var verb;\n  if (options.inject)\n    verb = 'Injected';\n\n  else if (!resolution.fresh) {\n    if (!options.link)\n      verb = 'Installed';\n    else\n      verb = 'Linked';\n  }\n  else {\n    if (options.quick)\n      return;\n    if (!options.link)\n      verb = 'Up to date -';\n    else\n      verb = 'Already linked -';\n  }\n\n  if (options.parent)\n    ui.log('ok', verb + ' `' + target.exactName + '` (' + resolution.version + ')');\n  else\n    ui.log('ok', verb + ' %' + name + '% as `' + target.exactName + '` (' + resolution.version + ')');\n}\n\nfunction getUpdateRangeText(existing, update) {\n  if (existing.name === update.name)\n    return '`' + existing.version + '` -> `' + update.version + '`';\n  else\n    return '`' + existing.exactName + '` -> `' + update.exactName + '`';\n}\n\n// go through the baseMap and depMap, changing FROM to TO\n// keep a log of what we did in resolveLog\nfunction doResolution(tree, from, to) {\n  if (from.exactName === to.exactName)\n    return;\n\n  // add this to the resolve log, including deep-updating resolution chains\n  logResolution(tree === installed ? installedResolves : installingResolves, from, to);\n\n  Object.keys(tree.baseMap).forEach(function(dep) {\n    if (tree.baseMap[dep].exactName === from.exactName)\n      tree.baseMap[dep] = to.copy();\n  });\n\n  Object.keys(tree.depMap).forEach(function(parent) {\n    var curMap = tree.depMap[parent];\n    Object.keys(curMap).forEach(function(dep) {\n      if (curMap[dep].exactName === from.exactName)\n        curMap[dep] = to.copy();\n    });\n  });\n}\n\nfunction logResolution(resolveLog, from, to) {\n  resolveLog[from.exactName] = to.exactName;\n\n  Object.keys(resolveLog).forEach(function(resolveFrom) {\n    if (resolveLog[resolveFrom] === from.exactName)\n      resolveLog[resolveFrom] = to.exactName;\n  });\n}\n\n// name and parentName are the existing resolution target\n// so we only look up forks and not the original as well\nfunction loadExistingForkRanges(resolution, name, parentName, inject) {\n  var tree = installed;\n  return Promise.all(Object.keys(tree.baseMap).map(function(dep) {\n    if (!parentName && dep === name)\n      return;\n\n    var primary = tree.baseMap[dep];\n    if (primary.name !== resolution.name)\n      return;\n\n    return loadExistingRange(dep, null, inject);\n  }))\n  .then(function() {\n    return Promise.all(Object.keys(tree.depMap).map(function(parent) {\n      var curDepMap = tree.depMap[parent];\n\n      return Promise.all(Object.keys(curDepMap).map(function(dep) {\n        if (parent === parentName && dep === name)\n          return;\n\n        var secondary = curDepMap[dep];\n\n        if (secondary.name !== resolution.name)\n          return;\n\n        return loadExistingRange(dep, parent, inject);\n      }));\n    }));\n  });\n}\n\nfunction visitForkRanges(tree, resolution, name, parentName, visit) {\n  // now that we've got all the version ranges we need for consideration,\n  // go through and run resolutions against the fork list\n  Object.keys(tree.baseMap).forEach(function(dep) {\n    var primary = tree.baseMap[dep];\n    if (primary.name !== resolution.name)\n      return;\n\n    visit(dep, null, primary, primaryRanges[dep]);\n  });\n\n  Object.keys(tree.depMap).forEach(function(parent) {\n    var curDepMap = tree.depMap[parent];\n\n    Object.keys(curDepMap).forEach(function(dep) {\n      var secondary = curDepMap[dep];\n\n      if (secondary.name !== resolution.name)\n        return;\n\n      // its not a fork of itself\n      if (dep === name && parent === parentName)\n        return;\n\n      // skip if we don't have a range\n      if (!secondaryRanges[parent])\n        return;\n\n      visit(dep, parent, secondary, secondaryRanges[parent][dep]);\n    });\n  });\n}\n\n// find all forks of this resolution in the tree\n// calling resolve(forkVersion, forkRanges, allSecondary)\n// for each unique fork version\n// sync resolution to avoid conflicts\nfunction resolveForks(tree, name, parentName, resolution, resolve) {\n  // forks is a map from fork versions to an object, { ranges, hasPrimary }\n  // hasPrimary indicates whether any of these ranges are primary ranges\n  var forks = {};\n  var forkVersions = [];\n\n  visitForkRanges(tree, resolution, name, parentName, function(dep, parent, resolved, range) {\n    if (!range)\n      return;\n\n    // we only work with stuff within it's own matching range\n    // not user overrides\n    if (range.name !== resolved.name || !semver.match(range.version, resolved.version))\n      return;\n\n    var forkObj = forks[resolved.version];\n    if (!forkObj) {\n      forkObj = forks[resolved.version] = { ranges: [], allSecondary: true };\n      forkVersions.push(resolved.version);\n    }\n\n    if (!parent)\n      forkObj.allSecondary = false;\n\n    forkObj.ranges.push(range.version);\n  });\n\n  // now run through and resolve the forks\n  forkVersions.sort(semver.compare).reverse().forEach(function(forkVersion) {\n    var forkObj = forks[forkVersion];\n\n    var newVersion = resolve(forkVersion, forkObj.ranges, forkObj.allSecondary);\n    if (!newVersion || newVersion === forkVersion)\n      return;\n\n    var from = resolution.copy().setVersion(forkVersion);\n    var to = resolution.copy().setVersion(newVersion);\n\n    doResolution(tree, from, to);\n  });\n}\n\nvar secondaryDepsPromises = {};\nfunction loadExistingRange(name, parent, inject) {\n  if (parent && secondaryRanges[parent] && secondaryRanges[parent][name])\n    return;\n  else if (!parent && primaryRanges[name])\n    return;\n\n  var _target;\n\n  return Promise.resolve()\n  .then(function() {\n    if (!parent)\n      return config.pjson.dependencies[name] || config.pjson.devDependencies[name];\n\n    return Promise.resolve()\n    .then(function() {\n      if (secondaryDepsPromises[parent])\n        return secondaryDepsPromises[parent];\n\n      return Promise.resolve()\n      .then(function() {\n        var parentPkg = new PackageName(parent);\n\n        // if the package is installed but not in jspm_packages\n        // then we wait on the getPackageConfig or download of the package here\n        return (secondaryDepsPromises[parent] = new Promise(function(resolve, reject) {\n          if (inject)\n            return pkg.inject(parentPkg, resolve).catch(reject);\n\n          if (config.deps[parentPkg.exactName])\n            return resolve();\n\n          pkg.download(parentPkg, {}, resolve).then(resolve, reject);\n        })\n        .then(function(depMap) {\n          if (depMap)\n            return depMap;\n\n          return config.deps[new PackageName(parent).exactName];\n        }));\n      });\n    })\n    .then(function(deps) {\n      return deps[name];\n    });\n  })\n  .then(function(target) {\n    if (!target) {\n      if (parent && installed.depMap[parent] && installed.depMap[parent].name) {\n        delete installed.depMap[parent].name;\n        ui.log('warn', '%' + parent + '% dependency %' + name + '% was removed from the config file to reflect the installed package.');\n      }\n      else if (!parent) {\n        ui.log('warn', '%' + name + '% is installed in the config file, but is not a dependency in the package.json. It is advisable to add it to the package.json file.');\n      }\n      return;\n    }\n\n    _target = target.copy();\n    // locate the target\n    return pkg.locate(_target)\n    .then(function(located) {\n      if (parent) {\n        secondaryRanges[parent] = secondaryRanges[parent] || {};\n        secondaryRanges[parent][name] = located;\n      }\n      else {\n        primaryRanges[name] = located;\n      }\n    });\n  });\n}\n\n\n// given an exact package, find all the forks, and display the ranges\nfunction showInstallGraph(pkg) {\n  installed = installed || config.loader;\n  pkg = new PackageName(pkg);\n  var lastParent;\n  var found;\n  return loadExistingForkRanges(pkg, config.loader.local)\n  .then(function() {\n    ui.log('info', '\\nInstalled versions of %' + pkg.name + '%');\n    visitForkRanges(installed, pkg, null, null, function(name, parent, resolved, range) {\n      found = true;\n      if (range.version === '')\n        range.version = '*';\n      var rangeVersion = range.name === resolved.name ? range.version : range.exactName;\n      if (range.version === '*')\n        range.version = '';\n\n      if (!parent)\n        ui.log('info', '\\n       %' + name + '% `' + resolved.version + '` (' + rangeVersion + ')');\n      else {\n        if (lastParent !== parent) {\n          ui.log('info', '\\n  ' + parent);\n          lastParent = parent;\n        }\n        ui.log('info', '    ' + name + ' `' + resolved.version + '` (' + rangeVersion + ')');\n      }\n    });\n    if (!found)\n      ui.log('warn', 'Package `' + pkg.name + '` not found.');\n    ui.log('');\n  });\n}\nexports.showInstallGraph = showInstallGraph;\n\n\nfunction showVersions(forks) {\n  installed = installed || config.loader;\n\n  var versions = {};\n  var haveLinked = false;\n  var linkedVersions = {};\n\n  function addDep(dep) {\n    var vList = versions[dep.name] = versions[dep.name] || [];\n    var version = dep.version;\n    try {\n      if (fs.readlinkSync(dep.getPath()))\n        linkedVersions[dep.exactName] = true;\n    }\n    catch(e) {}\n    if (vList.indexOf(version) === -1)\n      vList.push(version);\n  }\n\n  Object.keys(installed.baseMap).forEach(function(dep) {\n    addDep(installed.baseMap[dep]);\n  });\n  Object.keys(installed.depMap).forEach(function(parent) {\n    var curMap = installed.depMap[parent];\n    Object.keys(curMap).forEach(function(dep) {\n      addDep(curMap[dep]);\n    });\n  });\n\n  versions = alphabetize(versions);\n\n  var vLen = Object.keys(versions).map(function(dep) {\n    return dep.length;\n  }).reduce(function(a, b) {\n    return Math.max(a, b);\n  }, 0);\n\n  var shownIntro = false;\n\n  Object.keys(versions).forEach(function(dep) {\n    var vList = versions[dep].sort(semver.compare).map(function(version) {\n      if (linkedVersions[dep + '@' + version]) {\n        haveLinked = true;\n        return '%' + version + '%';\n      }\n      else\n        return '`' + version + '`';\n    });\n\n    if (forks && vList.length === 1)\n      return;\n\n    if (!shownIntro) {\n      ui.log('info', 'Installed ' + (forks ? 'Forks' : 'Versions') + '\\n');\n      shownIntro = true;\n    }\n\n    var padding = vLen - dep.length;\n    var paddingString = '';\n    while(padding--)\n      paddingString += ' ';\n\n    ui.log('info', '  ' + paddingString + '%' + dep + '% ' + vList.join(' '));\n  });\n\n  if (haveLinked) {\n    ui.log('info', '\\nBold versions are linked. To unlink use %jspm install --unlink [name]%.');\n  }\n  if (shownIntro) {\n    ui.log('info', '\\nTo inspect individual package constraints, use %jspm inspect registry:name%.\\n');\n  }\n  else if (forks) {\n    ui.log('ok', 'Install tree has no forks.');\n  }\n}\nexports.showVersions = showVersions;\n\n/*\n * Configuration cleaning\n *\n * 1. Construct list of all packages in main tree tracing from package.json primary installs\n * 2. Remove all orphaned dependencies not in this list\n * 3. Remove any package.json overrides that will never match this list\n * 4. Remove packages in .dependencies.json that aren't used at all\n * 5. Remove anything from jspm_packages not in this list\n *\n */\nfunction clean() {\n  var packageList = [];\n\n  return config.load()\n  .then(function() {\n\n    // 1. getDependentPackages for each of baseMap\n    Object.keys(config.loader.baseMap).forEach(function(dep) {\n      getDependentPackages(config.loader.baseMap[dep].exactName, packageList);\n    });\n\n    // 2. now that we have the package list, remove everything not in it\n    Object.keys(config.loader.depMap).forEach(function(dep) {\n      if (packageList.indexOf(dep) === -1) {\n        ui.log('info', 'Clearing configuration for `' + dep + '`');\n        delete config.loader.depMap[dep];\n      }\n    });\n\n    // 3. remove package.json overrides which will never match any packages\n    var usedOverrides = [];\n    packageList.forEach(function(pkgName) {\n      var pkgVersion = pkgName.split('@').pop();\n      pkgName = pkgName.substr(0, pkgName.length - pkgVersion.length - 1);\n\n      var overrideVersion = Object.keys(config.pjson.overrides)\n      .filter(function(overrideName) {\n        return overrideName.startsWith(pkgName + '@');\n      })\n      .map(function(overrideName) {\n        return overrideName.split('@').pop();\n      })\n      .filter(function(overrideVersion) {\n        return semver.match('^' + overrideVersion, pkgVersion);\n      })\n      .sort(semver.compare).pop();\n      if (overrideVersion)\n        usedOverrides.push(pkgName + '@' + overrideVersion);\n    });\n    Object.keys(config.pjson.overrides).forEach(function(overrideName) {\n      if (usedOverrides.indexOf(overrideName) == -1) {\n        ui.log('info', 'Removing unused package.json override `' + overrideName + '`');\n        delete config.pjson.overrides[overrideName];\n      }\n    });\n  })\n\n  .then(function() {\n    return asp(fs.lstat)(config.pjson.packages)\n    .catch(function(e) {\n      if (e.code == 'ENOENT')\n        return;\n      throw e;\n    }).then(function(stats) {\n      // Skip if jspm_packages is symlinked or not existing\n      if (!stats || stats.isSymbolicLink())\n        return;\n\n      // 4. Remove packages in .dependencies.json that aren't used at all\n      Object.keys(config.deps).forEach(function(dep) {\n        if (packageList.indexOf(dep) == -1)\n          delete config.deps[dep];\n      });\n\n      // 5. Remove anything from jspm_packages not in this list\n      return readDirWithDepth(config.pjson.packages, function(dirname) {\n        if (dirname.split(path.sep).pop().indexOf('@') <= 0)\n          return true;\n      })\n      .then(function(packageDirs) {\n        return Promise.all(\n        packageDirs\n        .filter(function(dir) {\n          var exactName = path.relative(config.pjson.packages, dir).replace(path.sep, ':').replace(/\\\\/g, '/'); // (win)\n          var remove = packageList.indexOf(exactName) === -1;\n          if (remove)\n            ui.log('info', 'Removing package files for `' + exactName + '`');\n          return remove;\n        })\n        .map(function(dir) {\n          return asp(rimraf)(dir)\n          .then(function() {\n            var filename = dir + '.js';\n            return new Promise(function(resolve) {\n              fs.exists(filename, resolve);\n            }).then(function(exists) {\n              if (exists) return asp(fs.unlink)(filename);\n            });\n          })\n          .then(function() {\n            return cascadeDelete(dir);\n          });\n        }));\n      });\n    });\n  })\n\n  .then(function() {\n    return config.save();\n  });\n}\nexports.clean = clean;\n\n// depthCheck returns true to keep going (files being ignored), false to add the dir to the flat list\nfunction readDirWithDepth(dir, depthCheck) {\n  var flatDirs = [];\n  return asp(fs.readdir)(dir)\n  .then(function(files) {\n    if (!files)\n      return [];\n    return Promise.all(files.map(function(file) {\n      var filepath = path.resolve(dir, file);\n\n      // ensure it is a directory\n      return asp(fs.lstat)(filepath)\n      .then(function(fileInfo) {\n        if (!fileInfo.isDirectory())\n          return;\n\n        if (!depthCheck(filepath))\n          return flatDirs.push(filepath);\n\n        // keep going\n        return readDirWithDepth(filepath, depthCheck)\n        .then(function(items) {\n          items.forEach(function(item) {\n            flatDirs.push(item);\n          });\n        });\n      });\n    }));\n  })\n  .then(function() {\n    return flatDirs;\n  });\n}\n\n\nfunction getDependentPackages(pkg, packages) {\n  packages.push(pkg);\n  // get all immediate children of this package\n  // for those children not already seen (in packages list),\n  // run getDependentPackages in turn on those\n  var depMap = config.loader.depMap[pkg];\n  if (!depMap)\n    return;\n  Object.keys(depMap).forEach(function(dep) {\n    var curPkg = depMap[dep].exactName;\n    if (packages.indexOf(curPkg) !== -1)\n      return;\n    getDependentPackages(curPkg, packages);\n  });\n\n  return packages;\n}\n\nexports.uninstall = function(names) {\n  if (!(names instanceof Array))\n    names = [names];\n\n  return config.load()\n  .then(function() {\n    installed = installed || config.loader;\n\n    names.forEach(function(name) {\n      if (!config.pjson.dependencies[name] && !config.pjson.devDependencies[name])\n        ui.log('warn', 'Dependency %' + name + '% is not an existing primary install.');\n\n      delete config.pjson.dependencies[name];\n      delete config.pjson.devDependencies[name];\n      delete installed.baseMap[name];\n    });\n\n    return clean();\n  });\n};\n\n/*\n * Resolve all installs of the given package to a specific version\n */\nexports.resolveOnly = function(pkg) {\n  pkg = new PackageName(pkg);\n\n  if (!pkg.version || !pkg.registry) {\n    ui.log('warn', 'Resolve --only must take an exact package of the form `registry:pkg@version`.');\n    return Promise.reject();\n  }\n\n  var didSomething = false;\n\n  return config.load()\n  .then(function() {\n    Object.keys(config.loader.baseMap).forEach(function(name) {\n      var curPkg = config.loader.baseMap[name];\n      if (curPkg.registry === pkg.registry && curPkg.package === pkg.package && curPkg.version !== pkg.version) {\n        didSomething = true;\n        ui.log('info', 'Primary install ' + getUpdateRangeText(curPkg, pkg));\n        config.loader.baseMap[name] = pkg.copy();\n      }\n    });\n\n    Object.keys(config.loader.depMap).forEach(function(parent) {\n      var curMap = config.loader.depMap[parent];\n      Object.keys(curMap).forEach(function(name) {\n        var curPkg = curMap[name];\n        if (curPkg.registry === pkg.registry && curPkg.package === pkg.package && curPkg.version !== pkg.version) {\n          didSomething = true;\n          ui.log('info', 'In %' + parent + '% ' + getUpdateRangeText(curPkg, pkg));\n          curMap[name] = pkg.copy();\n        }\n      });\n    });\n\n    return config.save();\n  })\n  .then(function() {\n    if (didSomething)\n      ui.log('ok', 'Resolution to only use `' + pkg.exactName + '` completed successfully.');\n    else\n      ui.log('ok', '`' + pkg.exactName + '` is already the only version of the package in use.');\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-jspm/node_modules/jspm/lib/config.js":"/*\n *   Copyright 2014-2015 Guy Bedford (http://guybedford.com)\n *\n *   Licensed under the Apache License, Version 2.0 (the \"License\");\n *   you may not use this file except in compliance with the License.\n *   You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n *   Unless required by applicable law or agreed to in writing, software\n *   distributed under the License is distributed on an \"AS IS\" BASIS,\n *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *   See the License for the specific language governing permissions and\n *   limitations under the License.\n */\nexports.HOME = process.env.LOCALAPPDATA || process.env.HOME || process.env.HOMEPATH;\n\n// default newline to the appropriate value for the system\nexports.newLine = require('os').EOL;\nexports.tab = '  ';\n\nvar ui = require('./ui');\nvar fs = require('graceful-fs');\nvar path = require('path');\nvar PackageConfig = require('./config/package');\nvar LoaderConfig = require('./config/loader');\nvar mkdirp = require('mkdirp');\nvar extend = require('./common').extend;\nvar config = module.exports;\nvar asp = require('rsvp').denodeify;\nvar readJSON = require('./common').readJSON;\nvar PackageName = require('./config/package-name');\n\n// given a package.json file and an override\n// calculate the package.json file jspm will see\nexports.derivePackageConfig = function(pjson, override) {\n  var dpjson = extend({}, pjson);\n\n  // first derive the override\n  if (override || pjson.jspm)\n    dpjson.jspm = extend({}, pjson.jspm || {});\n\n  if (override)\n    extend(dpjson.jspm, override);\n\n  // then apply the override\n  if (override || pjson.jspm)\n    extend(dpjson, dpjson.jspm);\n\n  return dpjson;\n};\n\n// package and loader configuration objects that are created\nexports.pjson = null;\nexports.loader = null;\n\nvar loadPromise;\nexports.loaded = false;\nexports.load = function(prompts) {\n  if (loadPromise)\n    return loadPromise;\n\n  return (loadPromise = Promise.resolve()\n  .then(function() {\n\n    if (process.env.globalJspm === 'true')\n      ui.log('warn', 'Running jspm globally, it is advisable to locally install jspm via %npm install jspm --save-dev%.');\n\n    if (!process.env.jspmConfigPath)\n      return ui.confirm('Package.json file does not exist, create it?', true)\n      .then(function(create) {\n        if (!create)\n          throw 'Operation aborted.';\n      });\n  })\n  .then(function() {\n    config.pjsonPath = process.env.jspmConfigPath || path.resolve(process.cwd(), 'package.json');\n\n    config.pjson = new PackageConfig(config.pjsonPath);\n    return config.pjson.read(prompts);\n  })\n  .then(function(_prompts) {\n    // package.json can indicate if we need to run config prompts for a new package\n    prompts = prompts || _prompts;\n\n    if (fs.existsSync(config.pjson.configFile))\n      return;\n\n    return ui.confirm('Configuration file %' + path.relative(process.cwd(), config.pjson.configFile) + '% doesn\\'t exist, create it?', true)\n    .then(function(create) {\n      if (!create)\n        throw 'Operation aborted.';\n\n      // ensure config folder exists\n      return asp(mkdirp)(path.dirname(config.pjson.configFile));\n    });\n  })\n  .then(function() {\n    config.loader = new LoaderConfig(config.pjson.configFile);\n    return config.loader.read(prompts);\n  })\n  .then(function() {\n    return readJSON(path.resolve(config.pjson.packages, '.dependencies.json'));\n  })\n  .then(function(depsJSON) {\n    config.deps = setSerializedDeps(depsJSON);\n    config.loaded = true;\n  }));\n};\n\nexports.loadSync = function() {\n  if (config.loaded)\n    return;\n  if (loadPromise)\n    throw 'Configuration file is already loading.';\n  config.pjsonPath = process.env.jspmConfigPath || path.resolve(process.cwd(), 'package.json');\n  config.pjson = new PackageConfig(config.pjsonPath);\n  config.pjson.read(false, true);\n\n  if (!fs.existsSync(config.pjson.configFile))\n    throw 'No project configuration file not found. Looking for: ' + config.pjson.configFile;\n\n  config.loader = new LoaderConfig(config.pjson.configFile);\n  config.loader.read(false, true);\n\n  var depsJSON;\n  try {\n    depsJSON = JSON.parse(fs.readFileSync(path.resolve(config.pjson.packages, '.dependencies.json')));\n  }\n  catch(e) {\n    if (e.code == 'ENOENT')\n      depsJSON = {};\n    else\n      throw e;\n  }\n\n  config.deps = setSerializedDeps(depsJSON);\n\n  config.loaded = true;\n  loadPromise = Promise.resolve();\n};\n\nfunction getSerializedDeps(deps) {\n  var serializedDeps = {};\n  Object.keys(deps).forEach(function(dep) {\n    var depMap = deps[dep];\n    var serializedDepMap = serializedDeps[dep] = {};\n    Object.keys(depMap).forEach(function(dep) {\n      serializedDepMap[dep] = depMap[dep].exactName;\n    });\n  });\n  return serializedDeps;\n}\nfunction setSerializedDeps(serializedDeps) {\n  var deps = {};\n  Object.keys(serializedDeps).forEach(function(dep) {\n    var depMap = deps[dep] = {};\n    var serializedDepMap = serializedDeps[dep];\n    Object.keys(serializedDepMap).forEach(function(dep) {\n      if (typeof serializedDepMap[dep] == 'string')\n        depMap[dep] = new PackageName(serializedDepMap[dep]);\n    });\n  });\n  return deps;\n}\n\nvar savePromise;\nexports.save = function() {\n  if (savePromise)\n    return savePromise.then(exports.save);\n\n  return Promise.resolve()\n  .then(function() {\n    return config.loader.write();\n  })\n  .then(function() {\n    return config.pjson.write();\n  })\n  .then(function() {\n    return asp(mkdirp)(config.pjson.packages);\n  })\n  .then(function() {\n    return asp(fs.writeFile)(path.resolve(config.pjson.packages, '.dependencies.json'), JSON.stringify(getSerializedDeps(config.deps), null, 2));\n  })\n  .then(function() {\n    savePromise = undefined;\n  });\n};\n\n// checks to see if the package.json map config\n// is accurately reflected in the config file\n// - if the config file has a property not in the package.json, we set it in the package.json\n// - if the package.json has a property not in the config, we set it in the config\n// - where there is a conflict, we specifically ask which value to use\n/*\nfunction checkMapConfig() {\n  var conflictPromises = [];\n\n  if (config.map && hasProperties(config.map)) {\n\n    var depMap;\n\n    return Promise.resolve()\n    .then(function() {\n      if (!config.name)\n        return ui.input('Enter project name to use contextual mappings', 'app')\n        .then(function(name) {\n          config.name = name;\n\n          // if the lib directory is not in package.json, and we've given a name\n          // then the new lib default is the name not 'lib'\n          if (!pjsonCache.directories || !pjsonCache.directories.lib)\n            config.lib = path.resolve(config.dir, config.name);\n        });\n    })\n    .then(function() {\n      depMap = config.depMap[config.name] = config.depMap[config.name] || {};\n    })\n    .then(function() {\n      // check everything in package.json is reflected in config\n      return Promise.all(Object.keys(config.map).map(function(d) {\n        var curMap = config.map[d];\n\n        // ensure package-relative maps are relative and not named\n        if (curMap.startsWith(config.name) && curMap.endsWith('/'))\n          curMap = config.map[d] = '.' + curMap.substr(config.name.length);\n\n        // maps are package-relative\n        if (curMap.startsWith('./'))\n          curMap = config.name + curMap.substr(1);\n\n        if (depMap[d] && depMap[d].exactName !== curMap) {\n          return ui.confirm('The config file has a mapping, `' + d + ' -> ' + depMap[d].exactName\n            + '`, while in the %package.json% this is mapped to `' + curMap + '`. Update the package.json?')\n          .then(function(override) {\n            if (override) {\n              var mapVal = depMap[d].exactName;\n              if (mapVal.startsWith(config.name) && mapVal.endsWith('/'))\n                mapVal = '.' + mapVal.substr(config.name.length);\n              config.map[d] = mapVal;\n            }\n            else {\n              depMap[d] = new PackageName(curMap);\n            }\n          });\n        }\n        else if (!depMap[d]) {\n          depMap[d] = new PackageName(curMap);\n        }\n      }))\n    })\n    .then(function() {\n      // check everything in config is reflected in package.json\n      return Promise.all(Object.keys(depMap).map(function(d) {\n        // we've handled all package.json now\n        if (config.map[d])\n          return;\n\n        config.map[d] = depMap[d].exactName;\n      }));\n    });\n  }\n\n  return Promise.resolve();\n}\n*/\n","/home/travis/build/npmtest/node-npmtest-jspm/node_modules/jspm/lib/ui.js":"/*\n *   Copyright 2014-2015 Guy Bedford (http://guybedford.com)\n *\n *   Licensed under the Apache License, Version 2.0 (the \"License\");\n *   you may not use this file except in compliance with the License.\n *   You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n *   Unless required by applicable law or agreed to in writing, software\n *   distributed under the License is distributed on an \"AS IS\" BASIS,\n *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *   See the License for the specific language governing permissions and\n *   limitations under the License.\n */\n\nvar Promise = require('rsvp').Promise;\nvar chalk = require('chalk');\n\nvar apiResolver;\nvar logging = true;\n\nvar logBuffer = '';\nvar errBuffer = '';\n\nvar logged = false;\nvar cli = module.exports;\n\nvar ui = exports;\n\nui.logLevel = 3; // corresponds to 'info'\nvar logTypes = ['err', 'warn', 'ok', 'info', 'debug'];\n\n// if storing any logs, dump them on exit\nprocess.on('exit', function() {\n  if (!apiResolver) {\n    if (logBuffer)\n      process.stdout.write(logBuffer);\n    if (errBuffer)\n      process.stderr.write(errBuffer);\n  }\n});\n\nexports.setResolver = function(resolver) {\n  apiResolver = resolver;\n};\n\n// use the default option in all prompts\n// throws an error for prompts that don't take a default\nvar useDefaults;\nexports.useDefaults = function(_useDefaults) {\n  if (_useDefaults === undefined)\n    _useDefaults = true;\n  useDefaults = _useDefaults;\n};\n\nexports.setLogLevel = function(level) {\n  if (!level)\n    return;\n\n  var levelIndex = logTypes.indexOf(level);\n\n  if (levelIndex == -1)\n    ui.log('warn', 'Unknown log level: ' + level);\n  else\n    ui.logLevel = levelIndex;\n};\n\nvar format = exports.format = {\n  q: function(msg, opt) {\n    return moduleMsg(msg) + '' + (opt ? ' [' + opt + ']' : '') + ':';\n  },\n  err: function(msg) {\n    return '\\n' + chalk.red.bold('err  ') + moduleMsg(msg);\n  },\n  info: function(msg) {\n    return '     ' + moduleMsg(msg);\n  },\n  warn: function(msg) {\n    return '\\n' + chalk.yellow.bold('warn ') + moduleMsg(msg);\n  },\n  ok: function(msg) {\n    return chalk.green.bold('ok   ') + moduleMsg(msg);\n  }\n};\n\nexports.log = function(type, msg) {\n  if (apiResolver)\n    return apiResolver.emit('log', type, msg);\n\n  logged = true;\n  \n  if (arguments.length === 1) {\n    msg = type;\n    type = null;\n  }\n  \n  msg = msg || '';\n\n  if (type)\n    msg = format[type](msg.toString());\n\n  var logLevel = logTypes.indexOf(type);\n  if (logLevel == -1)\n    logLevel = 3;\n  if (logLevel <= ui.logLevel) {\n    if (logging) {\n      if (type != 'err')\n        console.log(msg);\n      else\n        console.error(msg);\n    }\n    else {\n      if (type != 'err')\n        logBuffer += msg + '\\n';\n      else\n        errBuffer += msg + '\\n';\n    }\n  }\n};\n\nfunction moduleMsg(msg) {\n  return msg\n    .replace(/(\\s|\\`|^)%([^%\\n]+)%/g, '$1' + chalk.bold('$2'))\n    .replace(/(\\s|^)\\`([^\\`\\n]+)\\`/g, '$1' + chalk.cyan('$2'))\n    .replace(/\\n\\r?( {0,4}\\w)/g, '\\n     $1');\n}\n\nvar inputQueue = [];\nvar confirm = exports.confirm = function(msg, def) {\n  if (useDefaults) {\n    if (def !== true && def !== false)\n      def = true;\n    process.stdout.write(format.q(msg) + (def ? 'Yes' : 'No') + '\\n');\n    return Promise.resolve(def);\n  }\n\n  if (apiResolver)\n    return new Promise(function(resolve) {\n      apiResolver.emit('prompt', {\n        type: 'confirm',\n        message: msg,\n        default: def\n      }, function(answer) {\n        resolve(answer);\n      });\n    });\n\n  var defText = 'y/n';\n  if (def === true)\n    defText = 'yes';\n  else if (def === false)\n    defText = 'no';\n  else\n    def = undefined;\n\n  var p = cli.input(msg, defText);\n  return p.then(function(reply) {\n    if (reply.match(/\\b(no|n)\\b/i))\n      return false;\n    else if (reply.match(/\\b(yes|y\\b)/i))\n      return true;\n    else if (def !== undefined)\n      return def;\n    else\n      return confirm(msg, def);\n  });\n};\n\nexports.input = function(msg, def, disableOutput, queue) {\n  if (useDefaults) {\n    process.stdout.write(format.q(msg) + def + '\\n');\n    return Promise.resolve(def);\n  }\n\n  if (apiResolver)\n    return new Promise(function(resolve) {\n      apiResolver.emit('prompt', {\n        type: 'input',\n        message: msg,\n        default: def\n      }, function(answer) {\n        resolve(answer.input);\n      });\n    });\n\n  if (arguments.length === 2)\n    disableOutput = false;\n\n  return new Promise(function(resolve, reject) {\n    if (!logging && !queue)\n      return inputQueue.push({\n        args: [msg, def, disableOutput, true],\n        resolve: resolve,\n        reject: reject\n      });\n\n    if (logging && logged)\n      process.stdout.write('\\n');\n    logging = false;\n    process.stdout.write(format.q(msg, def));\n    process.stdin.resume();\n    process.stdin.setEncoding('utf8');\n    if (disableOutput && process.stdin.isTTY)\n      process.stdin.setRawMode(disableOutput);\n    var inputVal = '';\n    process.stdin.on('data', function(chunk) {\n      var lastChar = chunk.substr(chunk.length - 1, 1);\n      if (lastChar === '\\n' || lastChar === '\\r' || lastChar === '\\u0004') {\n        if (disableOutput && process.stdin.isTTY)\n          process.stdin.setRawMode(false);\n        process.stdin.pause();\n        process.stdin.removeAllListeners('data');\n        inputVal += chunk.substr(0, chunk.length - 1);\n\n        if (disableOutput)\n          process.stdout.write('\\n');\n\n        // bump the input queue\n        var next = inputQueue.shift();\n        if (next)\n          cli.input.apply(null, next.args).then(next.resolve, next.reject);\n        else {\n          process.stdout.write(logBuffer);\n          process.stderr.write(errBuffer);\n          logBuffer = '';\n          errBuffer = '';\n          logging = true;\n          logged = false;\n        }\n\n        resolve(inputVal.trim() || def);\n      }\n      inputVal += chunk;\n    });\n\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-jspm/node_modules/jspm/lib/config/package.js":"/*\n *   Copyright 2014-2015 Guy Bedford (http://guybedford.com)\n *\n *   Licensed under the Apache License, Version 2.0 (the \"License\");\n *   you may not use this file except in compliance with the License.\n *   You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n *   Unless required by applicable law or agreed to in writing, software\n *   distributed under the License is distributed on an \"AS IS\" BASIS,\n *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *   See the License for the specific language governing permissions and\n *   limitations under the License.\n */\n\nvar config = require('../config');\nvar path = require('path');\nvar extend = require('../common').extend;\nvar hasProperties = require('../common').hasProperties;\nvar Promise = require('rsvp').Promise;\nvar ui = require('../ui');\nvar fs = require('graceful-fs');\nvar asp = require('rsvp').denodeify;\nvar readJSONSync = require('../common').readJSONSync;\nvar alphabetize = require('../common').alphabetize;\nvar processDeps = require('../package').processDeps;\nvar stringify = require('../common').stringify;\n\nvar isWindows = process.platform.match(/^win/);\nvar winRegEx = /\\\\/g;\nfunction winPath(path) {\n  if (!isWindows)\n    return path;\n  return path.replace(winRegEx, '/');\n}\n\n/*\n * Package.json Configuration Class\n *\n * main\n * registry\n * dependencies\n * devDependencies\n * configFile\n * baseURL\n * packages\n * format\n * map\n * buildConfig\n * overrides\n *\n */\nfunction PackageJSON(fileName) {\n  this.fileName = fileName;\n}\n\nPackageJSON.prototype.read = function(prompts, sync) {\n  if (this.__read)\n    throw 'Package.json file already read';\n\n  this.__read = true;\n  var self = this;\n  var pjson;\n\n  var _pjson = readJSONSync(this.fileName);\n  self.originalPjson = _pjson;\n\n  self.jspmPrefix = true;\n  if ((_pjson.registry || _pjson.jspm === true) && typeof _pjson.jspm != 'object')\n    self.jspmPrefix = false;\n\n  // if we have dependencies in `jspm` prefix, assume devDependencies are too\n  if (_pjson.jspm && _pjson.jspm.dependencies) {\n    if (_pjson.devDependencies)\n      _pjson.jspm.devDependencies = _pjson.jspm.devDependencies || {};\n  }\n  // and vice versa\n  if (_pjson.jspm && _pjson.jspm.devDependencies) {\n    if (_pjson.dependencies)\n      _pjson.jspm.dependencies = _pjson.jspm.dependencies || {};\n  }\n\n  // derive the jspm config from the 'jspm' property in the package.json\n  // also sets the registry property if dependencies are jspm-prefixed\n  pjson = config.derivePackageConfig(_pjson);\n\n  self.pjson = pjson;\n\n  // not already jspm-configured\n  if (!_pjson.jspm && !_pjson.registry) {\n    prompts = true;\n    // dont read dependencies or devDependencies in this case\n    delete pjson.dependencies;\n    delete pjson.devDependencies;\n    // if dependencies already existing, override with empty dependencies\n    if (self.originalPjson.dependencies)\n      pjson.dependencies = {};\n    if (self.originalPjson.devDependencies)\n      pjson.devDependencies = {};\n  }\n\n  prompts = prompts || (!_pjson.jspm && !_pjson.registry);\n\n  if (prompts) {\n    if (sync)\n      throw 'Package.json file has not been initialized by jspm before. Run jspm init first.';\n    return doInitPrompts(pjson, self.fileName, self.jspmPrefix)\n    .then(function(prefixed) {\n      self.jspmPrefix = prefixed;\n      setDefaults();\n      return true;\n    });\n  }\n\n  setDefaults();\n\n  function setDefaults() {\n    self.dir = path.dirname(self.fileName);\n\n    // populate defaults as we go\n    var defaults = self.defaults = {};\n\n    self.registry = pjson.registry;\n    self.dependencies = {};\n    self.devDependencies = {};\n    // only read dependencies when combined with a registry property\n    self.dependencies = processDeps(pjson.dependencies, self.registry);\n    self.devDependencies = processDeps(pjson.devDependencies, self.registry);\n\n    defaults.baseURL = self.dir;\n    self.baseURL = pjson.directories && pjson.directories.baseURL && path.resolve(self.dir, pjson.directories.baseURL) || defaults.baseURL;\n    if (self.baseURL === path.resolve('/')) {\n      ui.log('warn', 'Server baseURL should be a relative file path, reverting to `.`');\n      self.baseURL = self.dir;\n    }\n\n    defaults.packages = path.resolve(self.baseURL, 'jspm_packages');\n\n    defaults.main = path.join(self.baseURL, 'index');\n    self.main = pjson.main || defaults.main;\n\n    // NB can remove jspmPackages suport in time\n    self.packages = pjson.directories && pjson.directories.packages && path.resolve(self.dir, pjson.directories.packages) ||\n      pjson.directories && pjson.directories.jspmPackages && path.resolve(self.dir, pjson.directories.jspmPackages) || defaults.packages;\n\n    defaults.configFile = path.resolve(self.baseURL, 'config.js');\n    self.configFile = pjson.configFile && path.resolve(self.dir, pjson.configFile) || defaults.configFile;\n\n    self.format = pjson.format;\n    self.map = extend({}, pjson.map || {});\n\n    self.buildConfig = extend({}, pjson.buildConfig || {});\n    self.overrides = extend({}, pjson.overrides || {});\n  }\n\n  // warn on invalid configs\n  if (path.relative(self.baseURL, self.packages)[0] == '.')\n    ui.log('warn', 'jspm_packages must be specified in the package.json within the baseURL for paths to resolve correctly.');\n};\n\nPackageJSON.prototype.write = function() {\n  var pjson = this.jspmPrefix ? {} : this.originalPjson;\n\n  if (!this.jspmPrefix && this.registry !== 'jspm')\n    pjson.jspm = true;\n\n  // set the registry property\n  if (this.jspmPrefix && this.registry !== 'jspm' || this.originalPjson.jspm && this.originalPjson.jspm.registry === 'jspm')\n    pjson.registry = this.registry;\n\n  var defaults = this.defaults;\n\n  function set(property, value, setValue) {\n    if (property in defaults && defaults[property] === value)\n      delete pjson[property];\n    else if (setValue !== undefined)\n      pjson[property] = setValue;\n    else if (value !== undefined)\n      pjson[property] = value;\n  }\n\n  // only set properties that differ from the defaults\n  // we set what we want the \"derived\" pjson to be first\n  set('main', this.main);\n  set('format', this.format);\n\n  var directories = extend({}, this.pjson.directories);\n  if (this.baseURL !== defaults.baseURL)\n    directories.baseURL = winPath(path.relative(this.dir, this.baseURL)) || '.';\n  else\n    delete directories.baseURL;\n  if (this.packages !== defaults.packages)\n    directories.packages = winPath(path.relative(this.dir, this.packages)) || '.';\n  else\n    delete directories.packages;\n\n  pjson.directories = alphabetize(directories);\n\n  set('configFile', this.configFile, winPath(path.relative(this.dir, this.configFile)));\n\n  pjson.map = alphabetize(this.map);\n\n  pjson.dependencies = writeDependencies(this.dependencies, this.registry);\n\n  pjson.devDependencies = writeDependencies(this.devDependencies, this.registry);\n\n  pjson.buildConfig = this.buildConfig;\n  pjson.overrides = this.overrides;\n\n  var self = this;\n  // remove any empty object properties that aren't nulling a base property\n  Object.keys(pjson).forEach(function(key) {\n    var val = pjson[key];\n    if (typeof val !== 'object' || hasProperties(val))\n      return;\n    if (!self.jspmPrefix || !(key in self.originalPjson))\n      delete pjson[key];\n  });\n\n  // for jspm prefixing, work out what we need to get desired package.json\n  if (this.jspmPrefix) {\n    for (var p in pjson) {\n      if (this.originalPjson[p] === pjson[p])\n        delete pjson[p];\n    }\n    this.originalPjson.jspm = pjson;\n  }\n\n  return asp(fs.readFile)(this.fileName).then(function(content) {\n    if (content.toString() === stringify(self.originalPjson) + config.newLine) {\n      return Promise.resolve();\n    } else {\n      return asp(fs.writeFile)(self.fileName, stringify(self.originalPjson) + config.newLine);\n    }\n  }).catch(function() {\n    return asp(fs.writeFile)(self.fileName, stringify(self.originalPjson) + config.newLine);\n  });\n};\n\nfunction writeDependencies(dependencies, registry) {\n  var outDependencies = {};\n  var depValue;\n  for (var dkey in dependencies) {\n    if (!dependencies.hasOwnProperty(dkey))\n      continue;\n    var dep = dependencies[dkey];\n    if (!dep)\n      continue;\n    if (dep.registry === registry) {\n      if (dkey === dep.package)\n        depValue = dep.version || '*';\n      else\n        depValue = dep.exactPackage;\n    }\n    else\n      depValue = dep.exactName;\n\n    outDependencies[dkey] = depValue;\n  }\n  return alphabetize(outDependencies);\n}\n\n// can take an existing non-jspm package.json\nfunction doInitPrompts(pjson, pjsonPath, prefixed) {\n  var baseDir = path.dirname(pjsonPath);\n  var base;\n\n  pjson.directories = pjson.directories || {};\n\n  return Promise.resolve()\n  .then(function() {\n    return ui.confirm('Would you like jspm to prefix the jspm package.json properties under %jspm%?', prefixed);\n  })\n  .then(function(prefix) {\n    prefixed = prefix;\n    return ui.input('Enter server baseURL (public folder path)', pjson.directories.baseURL || './');\n  })\n  .then(function(baseURL) {\n    base = path.relative(process.cwd(), path.resolve(baseURL));\n    baseURL = path.relative(baseDir, path.resolve(baseURL));\n    if (!base)\n      base = '.';\n    base += path.sep;\n    if (baseURL)\n      pjson.directories.baseURL = baseURL;\n    return ui.input('Enter jspm packages folder', pjson.directories.packages || base + 'jspm_packages');\n  })\n  .then(function(packages) {\n    pjson.directories.packages = path.relative(baseDir, path.resolve(packages));\n    return ui.input('Enter config file path', pjson.configFile || base + 'config.js');\n  })\n  .then(function(configFile) {\n    pjson.configFile = path.relative(baseDir, path.resolve(configFile));\n    return prefixed;\n  });\n}\n\nmodule.exports = PackageJSON;\n","/home/travis/build/npmtest/node-npmtest-jspm/node_modules/jspm/lib/common.js":"/*\n *   Copyright 2014-2015 Guy Bedford (http://guybedford.com)\n *\n *   Licensed under the Apache License, Version 2.0 (the \"License\");\n *   you may not use this file except in compliance with the License.\n *   You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n *   Unless required by applicable law or agreed to in writing, software\n *   distributed under the License is distributed on an \"AS IS\" BASIS,\n *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *   See the License for the specific language governing permissions and\n *   limitations under the License.\n */\nrequire('core-js/es6/string');\n\nvar asp = require('rsvp').denodeify;\nvar fs = require('graceful-fs');\nvar path = require('path');\nvar newLine = require('./config').newLine;\nvar tab = require('./config').tab;\n\nexports.toFileURL = function toFileURL(path) {\n  return 'file://' + (process.platform.match(/^win/) ? '/' : '') + path.replace(/\\\\/g, '/');\n};\n\nexports.fromFileURL = function fromFileURL(path) {\n  return path.substr(process.platform.match(/^win/) ? 8 : 7).replace(path.sep, '/');\n};\n\n// the opposite of extend\n// useful for setting default config\nexports.dprepend = function dprepend(a, b) {\n  for (var p in b) {\n    if (!b.hasOwnProperty(p))\n      continue;\n\n    var val = b[p];\n    if (typeof val === 'object')\n      dprepend(a[p] = typeof a[p] === 'object' ? a[p] : {}, val);\n    else if (!(p in a))\n      a[p] = val;\n  }\n  return a;\n};\n\nexports.extend = function(a, b) {\n  for (var p in b) {\n    if (b.hasOwnProperty(p)) {\n      a[p] = b[p];\n    }\n  }\n  return a;\n};\n\nfunction dextend(a, b) {\n  for (var p in b) {\n    if (!b.hasOwnProperty(p))\n      continue;\n    var val = b[p];\n    if (typeof val === 'object')\n      dextend(a[p] = typeof a[p] === 'object' ? a[p] : {}, val);\n    else\n      a[p] = val;\n  }\n  return a;\n}\nexports.dextend = dextend;\n\nexports.hasProperties = function(obj) {\n  for (var p in obj) {\n    if (obj.hasOwnProperty(p))\n      return true;\n  }\n  return false;\n};\n\nexports.readJSON = function(file) {\n  return asp(fs.readFile)(file)\n  .then(function(pjson) {\n    pjson = pjson.toString();\n    // remove any byte order mark\n    if (pjson.startsWith('\\uFEFF'))\n      pjson = pjson.substr(1);\n    try {\n      return JSON.parse(pjson);\n    }\n    catch(e) {\n      throw 'Error parsing package.json file ' + file;\n    }\n  }, function(err) {\n    if (err.code === 'ENOENT')\n      return {};\n    throw err;\n  });\n};\n\nexports.readJSONSync = function(file) {\n  var pjson;\n  try {\n    pjson = fs.readFileSync(file).toString();\n  }\n  catch(e) {\n    if (e.code === 'ENOENT')\n      pjson = '{}';\n    else\n      throw e;\n  }\n  if (pjson.startsWith('\\uFEFF'))\n    pjson = pjson.substr(1);\n  try {\n    return JSON.parse(pjson);\n  }\n  catch(e) {\n    throw 'Error parsing package.json file ' + file;\n  }\n  return pjson;\n};\n\n// given an object, create a new object with the properties ordered alphabetically\nexports.alphabetize = function(obj) {\n  var newObj = {};\n  Object.keys(obj).sort().forEach(function(p) {\n    newObj[p] = obj[p];\n  });\n  return newObj;\n};\n\nexports.getRedirectContents = function(format, main) {\n  if (format === 'es6' || format === 'esm')\n    return 'export * from \"' + main + '\";\\nexport {default} from \"' + main + '\";';\n\n  else if (format === 'cjs' || format === 'global')\n    return 'module.exports = require(\"' + main + '\");';\n\n  else if (format === 'amd')\n    return 'define([\"' + main + '\"], function(main) {\\n  return main;\\n});';\n\n  else if (format === 'register')\n    return 'System.register([\"' + main + '\"], ' +\n      'function($__export) {\\n  return {  setters: [function(m) { for (var p in m) $__export(p, m[p]); }],  execute: function() {}  };\\n});';\n\n  else\n    throw 'Unknown module format ' + format + '.';\n};\n\nexports.stringify = function (subject) {\n  return JSON.stringify(subject, null, tab).replace(/\\n/g, newLine);\n};\n\n/* Recursively remove directory, all those above it, if they are empty.\n * Takes optional `stopDir` to terminate at. */\nfunction cascadeDelete(dir, stopDir) {\n  if (dir && dir !== stopDir) {\n    return asp(fs.rmdir)(dir)\n    .catch(function(err) {\n      // just continue if directory does not exist\n      if (err.code !== 'ENOENT')\n        throw err;\n    })\n    .then(function() {\n      return cascadeDelete(path.dirname(dir), stopDir);\n    })\n    .catch(function(err) {\n      // gracefully stop at first non-empty directory\n      if (err.code !== 'ENOTEMPTY')\n        throw err;\n    });\n  }\n}\n\nexports.cascadeDelete = cascadeDelete;\n","/home/travis/build/npmtest/node-npmtest-jspm/node_modules/jspm/lib/package.js":"/*\n *   Copyright 2014-2015 Guy Bedford (http://guybedford.com)\n *\n *   Licensed under the Apache License, Version 2.0 (the \"License\");\n *   you may not use this file except in compliance with the License.\n *   You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n *   Unless required by applicable law or agreed to in writing, software\n *   distributed under the License is distributed on an \"AS IS\" BASIS,\n *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *   See the License for the specific language governing permissions and\n *   limitations under the License.\n */\n\nrequire('core-js/es6/string');\n\nvar request = require('request');\nvar ui = require('./ui');\nvar semver = require('./semver');\nvar Promise = require('rsvp').Promise;\nvar asp = require('rsvp').denodeify;\nvar build = require('./build');\nvar config = require('./config');\nvar mkdirp = require('mkdirp');\nvar rimraf = require('rimraf');\nvar path = require('path');\nvar registry = require('./registry');\nvar PackageName = require('./config/package-name');\nvar globalConfig = require('./global-config');\nvar readJSON = require('./common').readJSON;\nvar getRedirectContents = require('./common').getRedirectContents;\nvar ncp = require('ncp');\nvar crypto = require('crypto');\nvar fs = require('graceful-fs');\n\nvar jspmVersion = require('../package.json').version.split('.').splice(0, 2).join('.');\n\n// we cache registry lookups here to allow reductions in config saving\nvar registryCache = exports.registryCache = {};\n\nfunction md5(input) {\n  var md5Hash = crypto.createHash('md5');\n  md5Hash.update(input);\n  return md5Hash.digest('hex');\n}\n\nvar _pkg = module.exports;\n\n// given a name like 'jquery', 'github:repo/thatwasmoved'\n// add the default registry endpoint to the name\n// so we now have 'jspm:jquery', 'github:repo/thatwasmoved'\n// then run the locate hook (if provided) of the registry\n// following redirects until the locate hook converges\n// getting 'github:components/jquery' and 'github:repo/redirected'\n// at this point, we have the final name for the target\nvar locateCache = {};\n// target is a PackageName object\nexports.locate = function(target) {\n  if (!target.registry) {\n    target = new PackageName(target.exactName);\n    target.setRegistry(globalConfig.config.defaultRegistry);\n  }\n\n  var endpoint = registry.load(target.registry);\n\n  if (!endpoint.locate)\n    return Promise.resolve(target);\n\n  locateCache[target.registry] = locateCache[target.registry] || {};\n\n  // NB enable versioned locate\n  return Promise.resolve()\n  .then(function() {\n    if (locateCache[target.registry][target.package])\n      return locateCache[target.registry][target.package];\n\n    return (locateCache[target.registry][target.package] = Promise.resolve(endpoint.locate(target.package))\n    .then(function(located) {\n      // NB support versioned registry\n      if (target.registry === globalConfig.config.defaultRegistry)\n        registryCache[target.package] = located.redirect;\n      return located;\n    }));\n  })\n  .then(function(located) {\n    if (!located)\n      return target;\n\n    if (located.redirect) {\n      var newTarget = new PackageName(located.redirect);\n      newTarget.setVersion(target.version);\n      return _pkg.locate(newTarget);\n    }\n\n    if (located.notfound)\n      throw 'Repo `' + target.name + '` not found.' +\n        (target.registry != 'npm' && target.package.split('/').length == 1 ? ' Perhaps try %jspm install npm:' + target.package + '%.' : '');\n\n    throw 'Invalid registry locate response for %' + target.registry + '%';\n  }, function() {\n    throw 'Error locating `' + target.name + '`.';\n  });\n};\n\nvar lookupPromises = {};\nvar lookups = {};\n\nexports.lookup = function(pkg, edge) {\n  return Promise.resolve()\n\n  // load the version map\n  .then(function() {\n    if (lookupPromises[pkg.package])\n      return lookupPromises[pkg.package];\n\n    ui.log('info', 'Looking up `' + pkg.name + '`');\n\n    lookupPromises[pkg.package] = Promise.resolve(registry.load(pkg.registry).lookup(pkg.package));\n    return lookupPromises[pkg.package];\n  })\n  .then(function(lookup) {\n    if (lookup.notfound)\n      throw 'Repo `' + pkg.name + '` not found!';\n\n    if (!lookup.versions)\n      throw 'Invalid registry lookup response for %' + pkg.registry + '%';\n\n    lookups[pkg.package] = lookup.versions;\n\n    return function(version) {\n      var opts = {edge: edge, latestVersion: lookup.latest};\n      var lookupObj = getVersionMatch(version, lookup.versions, opts);\n      if (!lookupObj)\n        return;\n\n      return new PackageName(pkg.name + '@' + lookupObj.version, true);\n    };\n  }, function() {\n    throw 'Error looking up `' + pkg.name + '`.';\n  });\n};\n\nexports.getVersionMatch = getVersionMatch;\nfunction getVersionMatch(pkgVersion, versions, options) {\n  // unescape pkgVersion for comparison\n  if (pkgVersion)\n    pkgVersion = decodeURIComponent(pkgVersion);\n\n  var version;\n  var stableSemver = [];\n  var unstableSemver = [];\n  var stableExact = [];\n  var unstableExact = [];\n  var edge = options && options.edge;\n\n  Object.keys(versions).forEach(function(v) {\n    version = versions[v];\n    var stable = version.stable;\n    var semverMatch = v.match(semver.semverRegEx);\n    var valid = semverMatch && semverMatch[1] && semverMatch[2] && semverMatch[3];\n    var pre = valid && semverMatch[4];\n\n    // store a reverse lookup\n    version.version = v;\n\n    // ignore non-semver or prerelease, unless explictly marked as stable\n    if (!valid) {\n      // unstable unless explicitly stable. in --edge prioritize all after 'master'\n      if (stable && !edge)\n        stableExact.push(v);\n      else\n        unstableExact.push(v);\n    }\n    // stable unless explicitly unstable or indetermate and a prerelease\n    // --edge considers all semver to be stable\n    else if (!edge && (stable === false || (stable !== true && pre)))\n      unstableSemver.push(v);\n    else\n      stableSemver.push(v);\n  });\n\n  function compareDesc(a, b) {\n    return semver.compare(b, a);\n  }\n\n  if (!pkgVersion) {\n    var latest = options && options.latestVersion && versions[options.latestVersion];\n    if (!edge && latest)\n      return latest;\n    stableSemver.sort(compareDesc);\n\n    if (stableSemver[0])\n      return versions[stableSemver[0]];\n\n    unstableSemver.sort(compareDesc);\n    if (unstableSemver[0])\n      return versions[unstableSemver[0]];\n\n    if (latest)\n      return latest;\n\n    stableExact.sort();\n    if (stableExact[0])\n      return versions[stableExact[0]];\n\n    // an ugly practicality. ideally designed out in future.\n    if (versions.master)\n      return versions.master;\n\n    unstableExact.sort();\n    if (unstableExact[0])\n      return versions[unstableExact[0]];\n  }\n  else {\n    var i, ver;\n    stableSemver.sort(compareDesc);\n    // find highest stable match in tags\n    for (i = 0; i < stableSemver.length; i++) {\n      ver = stableSemver[i];\n      var match = edge ? semver.matchUnstable : semver.match;\n      if (match(pkgVersion, ver))\n        return versions[ver];\n    }\n    unstableSemver.sort(compareDesc);\n    for (i = 0; i < unstableSemver.length; i++) {\n      ver = unstableSemver[i];\n      if (semver.match(pkgVersion, ver))\n        return versions[ver];\n    }\n    // finally check for an exact tag match\n    if (versions[pkgVersion])\n      return versions[pkgVersion];\n  }\n}\n\n// returns {hash,depRanges} or {notfound} or {linked}\nfunction getPackageDirInfo(dir) {\n  return Promise.resolve()\n  .then(function() {\n    // check if the folder already exists\n    return asp(fs.stat)(dir)\n    .then(function(stats) {\n      if (stats.isDirectory())\n        return true;\n      return asp(fs.unlink)(dir);\n    })\n    .catch(function(err) {\n      if (err.code === 'ENOENT')\n        return;\n      throw err;\n    });\n  })\n  .then(function(exists) {\n    if (!exists)\n      return { notfound: true };\n\n    // if it is linked, then it is fresh\n    return asp(fs.lstat)(dir)\n    .then(function(stats) {\n      return stats.isSymbolicLink();\n    })\n    .then(function(linked) {\n      if (linked)\n        return { linked: true };\n\n      // otherwise do the hash check\n      var hash;\n      return asp(fs.readFile)(path.resolve(dir, '.jspm-hash'))\n      .then(function(_hash) {\n        hash = _hash.toString();\n      })\n      .then(function() {\n        return readJSON(dir + '.deps.json');\n      })\n      .then(function(depJSON) {\n        var depRanges = {};\n        Object.keys(depJSON).forEach(function(dep) {\n          if (typeof depJSON[dep] == 'string')\n            depRanges[dep] = new PackageName(depJSON[dep]);\n        });\n        return { hash: hash, depRanges: depRanges };\n      }, function(err) {\n        if (err.code === 'ENOENT')\n          return { notfound: true };\n        throw err;\n      });\n    });\n  });\n}\n\nfunction processDeps(deps, registry) {\n  var outdeps = {};\n  if (!deps)\n    return outdeps;\n  Object.keys(deps).forEach(function(p) {\n    var dep = deps[p];\n\n    if (dep instanceof PackageName) {\n      outdeps[p] = dep;\n      return outdeps[p];\n    }\n\n    var outPackage;\n\n    // jquery: github:components/jquery\n    // jquery: jquery@1.5\n    // -> RHS is dep\n    if (dep.indexOf(':') !== -1)\n      outPackage = dep;\n\n    else if (!registry)\n      throw new TypeError('Install of %' + p + '% to `' + dep + '` has no registry property provided.');\n\n    // jquery: components/jquery@1.5\n    else if (dep.lastIndexOf('@') > 0)\n      outPackage = registry + ':' + dep;\n\n    // jquery: 1.5\n    else\n      outPackage = registry + ':' + p + '@' + dep;\n\n    outdeps[p] = new PackageName(outPackage, true);\n  });\n  return outdeps;\n}\nexports.processDeps = processDeps;\n\nvar injecting = {};\nexports.inject = function(pkg, depLoad) {\n  if (injecting[pkg.exactName]) {\n    injecting[pkg.exactName].depLoad.then(function(depMap) {\n      depLoad(depMap);\n      return depMap;\n    });\n    return injecting[pkg.exactName].promise;\n  }\n\n  injecting[pkg.exactName] = {};\n\n  var depResolve, depReject;\n  injecting[pkg.exactName].depLoad = new Promise(function(resolve, reject) {\n    depResolve = resolve;\n    depReject = reject;\n  })\n  .then(function(depMap) {\n    depLoad(depMap);\n    return depMap;\n  });\n\n  var remote = registry.load(pkg.registry).remote;\n\n  if (!remote)\n    throw 'Cannot inject from registry %' + pkg.registry + '% as it has no remote.';\n\n  // NB remove rejectUnauthorized\n  var url = remote + (remote.endsWith('/') ? '' : '/') + pkg.exactName.substr(pkg.exactName.indexOf(':') + 1) + '/.jspm.json';\n  injecting[pkg.exactName].promise = asp(request)({\n    method: 'get',\n    url: url,\n    rejectUnauthorized: false\n  }).then(function(res) {\n    if (res.statusCode !== 200)\n      throw new Error('Error requesting package.json for `' + pkg.exactName + '` at %' + url + '%.');\n\n    try {\n      return JSON.parse(res.body);\n    }\n    catch(e) {\n      throw new Error('Unable to parse package.json');\n    }\n  })\n  .then(function(pjson) {\n    depResolve(processDeps(pjson.dependencies, pjson.registry));\n    return pjson;\n  }, depReject);\n  return injecting[pkg.exactName].promise;\n};\n\nfunction getDepRanges(pjson) {\n  var depRanges = processDeps(pjson.dependencies, pjson.registry);\n  \n  // dont install re-mapped dependencies\n  Object.keys(depRanges).forEach(function(dep) {\n    if (pjson.map && pjson.map[dep])\n      delete depRanges[dep];\n  });\n\n  return depRanges;\n}\n\n\n// note if it is a symlink, we leave it unaltered\nvar downloading = {};\n// options.override\n// options.unlink\n// options.quick\nexports.download = function(pkg, options, installDeps) {\n  var sentDeps;\n  // called twice, ensure we don't duplicate install requests back\n  function depsCallback(depRanges) {\n    if (sentDeps)\n      Object.keys(depRanges).forEach(function(dep) {\n        if (sentDeps.indexOf(dep) != -1)\n          delete depRanges[dep];\n      });\n    else\n      sentDeps = Object.keys(depRanges);\n    if (installDeps)\n      installDeps(depRanges);\n    return depRanges;\n  }\n\n  // download queue\n  if (downloading[pkg.exactName]) {\n    downloading[pkg.exactName].preload.then(depsCallback);\n    downloading[pkg.exactName].postload.then(depsCallback);\n    return downloading[pkg.exactName].promise;\n  }\n  var postloadResolve, preloadResolve;\n  downloading[pkg.exactName] = {\n    preload: new Promise(function(resolve) {\n      preloadResolve = resolve;\n    })\n    .then(depsCallback),\n    postload: new Promise(function(resolve) {\n      postloadResolve = resolve;\n    })\n    .then(depsCallback)\n  };\n\n  // download\n  var override = options.override;\n  var downloadDir = pkg.getPath();\n  var getPackageConfigPromise;\n\n  downloading[pkg.exactName].promise = Promise.resolve()\n  .then(function() {\n    // if we have no constraint information, it's immediately a not-found\n    if (!config.deps[pkg.exactName])\n      return { notfound: true };\n\n    // otherwise check the folder info\n    return getPackageDirInfo(downloadDir);\n  })\n  .then(function(dirInfo) {\n    if (dirInfo.linked && !options.unlink)\n      return preloadResolve(config.deps[pkg.exactName]);\n\n    var cacheDir = path.resolve(config.HOME, '.jspm', 'packages', pkg.registry, pkg.exactPackage);\n\n    var endpoint = registry.load(pkg.registry);\n\n    var hash;\n    var fullHash;\n    var meta;\n\n    var fresh;\n\n    return (options.quick && dirInfo.hash ? Promise.resolve(true) : Promise.all([\n      // ensure we have the hash from the lookup\n      _pkg.lookup(pkg, options.edge)\n      .then(function() {\n        var lookupObj = lookups[pkg.package][pkg.version];\n        if (!lookupObj && !options.link)\n          throw 'Unable to resolve version %' + pkg.version + '% for `' + pkg.package + '`.';\n\n        if (lookupObj) {\n          hash = lookupObj.hash;\n          meta = lookupObj.meta;\n        }\n        // linked packages have no lookup object\n        else {\n          hash = '';\n          meta = {};\n        }\n      }),\n\n      // and the override\n      Promise.resolve()\n      .then(function() {\n        // load the registry endpoint\n        var endpoint = registry.load(globalConfig.config.defaultRegistry);\n\n        // get the override\n        if (endpoint.getOverride) {\n          if (!override) {\n            var overrideVersion = Object.keys(config.pjson.overrides)\n            .filter(function(overrideName) {\n              return overrideName.startsWith(pkg.name + '@');\n            })\n            .map(function(overrideName) {\n              return overrideName.split('@').pop();\n            })\n            .filter(function(overrideVersion) {\n              return semver.match('^' + overrideVersion, pkg.version);\n            })\n            .sort(semver.compare).pop();\n            if (overrideVersion) {\n              override = config.pjson.overrides[pkg.name + '@' + overrideVersion];\n              ui.log('warn', 'Using local override for `' + pkg.exactName + '`');\n            }\n          }\n          return endpoint.getOverride(pkg.registry, pkg.package, pkg.version, override);\n        }\n\n        return override;\n      })\n      .then(function(_override) {\n        override = _override;\n      })\n    ]))\n    .then(function() {\n      if (options.quick && dirInfo.hash)\n        return true;\n\n      // create the full package hash by combining it with the override and registry code hash\n      fullHash = hash + md5(JSON.stringify(override || {})) + endpoint.versionString + jspmVersion + '.1';\n\n      if (config.force)\n        return false;\n\n      return dirInfo.hash === fullHash;\n    })\n    .then(function(_fresh) {\n      fresh = _fresh;\n      if (fresh) {\n        // this can't trigger twice, so if its a second call its just a noop\n        preloadResolve(config.deps[pkg.exactName]);\n        return true;\n      }\n\n      // ensure global cache is fresh / download if not\n      return Promise.resolve(config.force ? false : getPackageDirInfo(cacheDir))\n      .then(function(cacheInfo) {\n        if (cacheInfo.hash && cacheInfo.hash === fullHash) {\n          config.deps[pkg.exactName] = cacheInfo.depRanges;\n          preloadResolve(cacheInfo.depRanges);\n          return;\n        }\n\n        ui.log('info', 'Downloading `' + pkg.exactName + '`');\n\n        if (endpoint.getPackageConfig)\n          getPackageConfigPromise = Promise.resolve()\n          .then(function() {\n            return endpoint.getPackageConfig(pkg.package, pkg.version, hash, meta);\n          })\n          .then(function(pjson) {\n            return derivePackageConfig(pkg, pjson, override);\n          }, function() {\n            throw 'Error getting package config for `' + pkg.name + '`.';\n          })\n          .then(function(pjson) {\n            preloadResolve(getDepRanges(pjson));\n            return pjson;\n          });\n\n        return Promise.resolve(cacheDir)\n        // ensure the download directory exists\n        .then(asp(mkdirp))\n        // clear the directory\n        .then(function() {\n          return asp(rimraf)(cacheDir);\n        })\n        .then(function() {\n          return asp(fs.unlink)(cacheDir + '.js')\n          .catch(function() {});\n        })\n        // create it\n        .then(function() {\n          return asp(mkdirp)(cacheDir);\n        })\n        // do the download\n        .then(function() {\n          return endpoint.download(pkg.package, pkg.version, hash, meta, cacheDir);\n        })\n\n        // process the package fully\n        .then(function(pjson) {\n          // if we have a getPackageConfig, we use that pjson\n          if (endpoint.getPackageConfig)\n            return getPackageConfigPromise;\n\n          // if no pjson returned by download, just read from download folder\n          return Promise.resolve(pjson || readJSON(path.resolve(cacheDir, 'package.json')))\n          .then(function(pjson) {\n            return derivePackageConfig(pkg, pjson, override);\n          });\n        }, function(err) {\n          if (err)\n            ui.log('err', err && err.stack || err);\n          throw 'Error downloading `' + pkg.name + '`.';\n        })\n        .then(function(pjson) {\n          return _pkg.processPackage(pkg, cacheDir, pjson, postloadResolve);\n        })\n        // create the main file in the cache folder\n        .then(function(pjson) {\n          return _pkg.createMain(pkg, pjson, cacheDir)\n          .then(function() {\n            return pjson;\n          });\n        })\n        // create the deps file in the cache folder\n        .then(function(pjson) {\n          var depRanges = getDepRanges(pjson);\n          var rangeMap = {};\n          Object.keys(depRanges).forEach(function(dep) {\n            rangeMap[dep] = depRanges[dep].exactName;\n          });\n          config.deps[pkg.exactName] = depRanges;\n          return asp(fs.writeFile(cacheDir + '.deps.json', JSON.stringify(rangeMap, null, 2)));\n        })\n        // we've now finished creating the cache directory\n        .then(function() {\n          return asp(fs.writeFile)(path.resolve(cacheDir, '.jspm-hash'), fullHash);\n        });\n      })\n      // copy global cache to local install\n      // clear the directory\n      .then(function() {\n        // in case it was linked, try and remove\n        return asp(fs.unlink)(downloadDir)\n        .catch(function(e) {\n          if (e.code === 'EISDIR' || e.code === 'EPERM' || e.code === 'ENOENT')\n            return;\n          throw e;\n        });\n      })\n      .then(function() {\n        return asp(mkdirp)(downloadDir);\n      })\n      .then(function() {\n        return asp(rimraf)(downloadDir);\n      })\n      .then(function() {\n        return asp(ncp)(cacheDir, downloadDir);\n      })\n      .then(function() {\n        // copy main file from cached folder (if it exists)\n        return asp(ncp)(cacheDir + '.js', downloadDir + '.js')\n        .catch(function(err) {\n          if (err instanceof Array)\n            err = err[0];\n          if (err.code == 'ENOENT')\n            return;\n          throw err;\n        });\n      })\n      .then(function() {\n        return fresh;\n      });\n    });\n  });\n  return downloading[pkg.exactName].promise;\n};\n\n\n// like config.derivePackageConfig, but applies the\n// registry processPackageConfig operation as well\nfunction derivePackageConfig(pkg, pjson, override) {\n  pjson = config.derivePackageConfig(pjson, override);\n\n  var endpoint = registry.load(pjson.registry || pkg.registry);\n  return Promise.resolve(endpoint.processPackageConfig ? endpoint.processPackageConfig(pjson, pkg.exactName) : pjson)\n  .then(function(pjson) {\n    if (!pjson)\n      throw new Error('processPackageConfig must return the processed package.json object.');\n    pjson.registry = pjson.registry || pkg.registry;\n    return pjson;\n  })\n  .catch(function() {\n    throw 'Error processing package config for `' + pkg.name + '`.';\n  });\n}\nexports.derivePackageConfig = derivePackageConfig;\n\n\n/*\n Given a raw package in a folder,\n apply the package.json build operations etc\n\n Also saves the hash into the folder\n\n pjson is optional if provided by getPackageConfig\n\n NB this function should be deprecated\n*/\nexports.processPackage = function(pkg, dir, pjson, postload, isCDN) {\n  // any package which takes longer than 10 seconds to process\n  var timeout = setTimeout(function() {\n    ui.log('warn', 'It\\'s taking a long time to process the dependencies of `' + pkg.exactName + '`.\\n' +\n      'This package may need an %ignore% property to indicate test or example folders for jspm to skip.\\n');\n  }, 10000);\n  var endpoint = registry.load(pjson.registry || pkg.registry);\n  var deps;\n  var buildErrors = [];\n  var curDeps = [];\n\n  return Promise.resolve()\n\n  .then(function() {\n    // now that we have the derived pjson, do the registry build\n    if (endpoint.build)\n      return Promise.resolve()\n      .then(function() {\n        curDeps = pjson.dependencies && Object.keys(pjson.dependencies) || [];\n        return endpoint.build(pjson, dir);\n      })\n      .catch(function() {\n        throw 'Error building package `' + pkg.name + '`.';\n      });\n  })\n\n  // apply build operations from the package.json\n  .then(function(_buildErrors) {\n    if (_buildErrors)\n      buildErrors = buildErrors.concat(_buildErrors);\n\n    // if we gained a new dependency, download it\n    postload(getDepRanges(pjson));\n\n    // don't build in dependencies\n    if (!isCDN) {\n      deps = pjson.dependencies;\n      delete pjson.dependencies;\n    }\n    else {\n      deps = pjson.dependencies;\n      pjson.dependencies = processDeps(pjson.dependencies, pjson.registry);\n    }\n\n    return build.buildPackage(dir, pjson, isCDN);\n  })\n\n  // save the final calculated package.json in place\n  .then(function(_buildErrors) {\n    if (_buildErrors)\n      buildErrors = buildErrors.concat(_buildErrors);\n    pjson.dependencies = deps;\n  })\n  .then(function() {\n    // write build errors\n    if (buildErrors.length)\n      return asp(fs.writeFile)(path.resolve(dir, '.jspm.errors'), buildErrors.join('\\n\\n'));\n  })\n  .then(function() {\n    clearTimeout(timeout);\n    return pjson;\n  });\n};\n\nexports.createMain = function(pkg, pjson, downloadDir) {\n  var lastNamePart, main;\n  var mainPath;\n  var pluginMain;\n\n  return Promise.resolve()\n\n  // create the main entry point\n  .then(function() {\n    lastNamePart = pkg.name.split('/').pop().split(':').pop();\n    main = typeof pjson.main === 'string' && pjson.main;\n\n    // we don't need to ensure it exists for plugin mains\n    // as they can have custom locate functions\n    if (main && main.indexOf('!') !== -1) {\n      pluginMain = true;\n      return true;\n    }\n\n    if (!main)\n      return false;\n\n    if (main.startsWith('./')) {\n      main = main.substr(2);    \n    }\n    \n    return new Promise(function(resolve) {\n      // Check to see if main points to an actual file or not\n      // i.e. does it include extension.\n      mainPath = path.resolve(downloadDir, main);\n      fs.exists(mainPath, resolve);\n    });\n  })\n  .then(function(exists) {\n    main = main || 'index';\n\n    return new Promise(function(resolve) {\n      // `main` does not have extension (or it does not point to an actual file).\n      // Try again with `.js` extension\n      mainPath = path.resolve(downloadDir, main + '.js');\n      fs.exists(mainPath, resolve);\n    })\n    .then(function(_exists) {\n      if (!_exists)\n        mainPath = path.resolve(downloadDir, main);\n      return exists || _exists;\n    });\n  })\n  .then(function(exists) {\n    if (exists)\n      return exists;\n\n    main = lastNamePart;\n\n    if (main.endsWith('.js'))\n      main = main.substr(0, main.length - 3);\n\n    return new Promise(function(resolve) {\n      mainPath = path.resolve(downloadDir, main + '.js');\n      fs.exists(mainPath, resolve);\n    });\n  })\n  .then(function(exists) {\n    // don't create a main if it doesn't exist\n    if (!exists) {\n      if (pjson.main !== false)\n        ui.log('warn', 'Main entry point not found for `' + pkg.exactName + '`.\\nAdjust this property in the package.json or with an override, setting %\"main\": false% if this is the intention.\\n');\n      return;\n    }\n\n    // create the main pointer\n    var mainFile = path.resolve(downloadDir, '../' + lastNamePart + '@' + pkg.version + '.js');\n\n    // plugin mains are redirected by CommonJS\n    if (pluginMain)\n      return asp(fs.writeFile)(mainFile, getRedirectContents('cjs', pkg.exactName + '/' + main));\n\n    // otherwise detect the format of the main\n    return asp(fs.readFile)(mainPath)\n    .catch(function(err) {\n      if (err.code == 'EISDIR')\n        return;\n      throw err;\n    })\n    .then(function(source) {\n      if (typeof source == 'undefined')\n        return;\n      var format = pjson.format || build.detectFormat(source.toString()).format;\n\n      return asp(fs.writeFile)(mainFile, getRedirectContents(format, pkg.exactName + '/' + main));\n    });\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-jspm/node_modules/jspm/lib/semver.js":"/*\n *   Copyright 2014-2015 Guy Bedford (http://guybedford.com)\n *\n *   Licensed under the Apache License, Version 2.0 (the \"License\");\n *   you may not use this file except in compliance with the License.\n *   You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n *   Unless required by applicable law or agreed to in writing, software\n *   distributed under the License is distributed on an \"AS IS\" BASIS,\n *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *   See the License for the specific language governing permissions and\n *   limitations under the License.\n */\n\nrequire('core-js/es6/string');\n\nvar semverRegEx = /^(\\d+)(?:\\.(\\d+)(?:\\.(\\d+)(?:-([\\da-z-]+(?:\\.[\\da-z-]+)*)(?:\\+([\\da-z-]+(?:\\.[\\da-z-]+)*))?)?)?)?$/i;\nvar numRegEx = /^\\d+$/;\n\nfunction toInt(num) {\n  return parseInt(num, 10);\n}\n\nfunction parseSemver(v) {\n  var semver = v.match(semverRegEx);\n  if (!semver)\n    return {\n      tag: v\n    };\n  else\n    return {\n      major: toInt(semver[1]),\n      minor: toInt(semver[2]),\n      patch: toInt(semver[3]),\n      pre: semver[4] && semver[4].split('.')\n    };\n}\n\nvar parts = ['major', 'minor', 'patch'];\nfunction semverCompareParsed(v1, v2, edge) {\n  // not semvers - tags have equal precedence\n  if (v1.tag && v2.tag)\n    return 0;\n\n  // semver beats non-semver\n  if (v1.tag)\n    return -1;\n  if (v2.tag)\n    return 1;\n\n  // compare version numbers\n  for (var i = 0; i < parts.length; i++) {\n    var part = parts[i];\n    var part1 = v1[part];\n    var part2 = v2[part];\n    if (part1 === part2)\n      continue;\n    if (isNaN(part1))\n      return -1;\n    if (isNaN(part2))\n      return 1;\n    return part1 > part2 ? 1 : -1;\n  }\n\n  if (!v1.pre && !v2.pre)\n    return 0;\n\n  if (!v1.pre)\n    return edge ? 0 : 1;\n  if (!v2.pre)\n    return -1;\n\n  // prerelease comparison\n  for (var j = 0, l = Math.min(v1.pre.length, v2.pre.length); j < l; j++) {\n    if (v1.pre[j] === v2.pre[j])\n      continue;\n\n    var isNum1 = v1.pre[j].match(numRegEx);\n    var isNum2 = v2.pre[j].match(numRegEx);\n\n    // numeric has lower precedence\n    if (isNum1 && !isNum2)\n      return -1;\n    if (isNum2 && !isNum1)\n      return 1;\n\n    // compare parts\n    if (isNum1 && isNum2)\n      return toInt(v1.pre[j]) > toInt(v2.pre[j]) ? 1 : -1;\n    else\n      return v1.pre[j] > v2.pre[j] ? 1 : -1;\n  }\n\n  if (v1.pre.length === v2.pre.length)\n    return 0;\n\n  // more pre-release fields win if equal\n  return v1.pre.length > v2.pre.length ? 1 : -1;\n}\n\n// match against a parsed range object\n// saves operation repetition\n// doesn't support tags\n// if not semver or fuzzy, assume exact\nfunction matchParsed(range, version, edge) {\n  var rangeVersion = range.version;\n\n  if (rangeVersion.tag)\n    return rangeVersion.tag === version.tag;\n\n  // if the version is less than the range, it's not a match\n  if (semverCompareParsed(rangeVersion, version, edge) === 1)\n    return false;\n\n  // now we just have to check that the version isn't too high for the range\n  if (isNaN(version.minor) || isNaN(version.patch))\n    return false;\n\n  // if the version has a prerelease, ensure the range version has a prerelease in it\n  // and that we match the range version up to the prerelease exactly\n  if (version.pre) {\n    if (!edge &&\n        !(rangeVersion.major === version.major &&\n          rangeVersion.minor === version.minor &&\n          rangeVersion.patch === version.patch))\n      return false;\n    return range.semver || range.fuzzy || rangeVersion.pre && rangeVersion.pre.join('.') === version.pre.join('.');\n  }\n\n  // check semver range\n  if (range.semver) {\n    // ^0\n    if (rangeVersion.major === 0 && isNaN(rangeVersion.minor))\n      return version.major < 1;\n    // ^1..\n    else if (rangeVersion.major >= 1)\n      return rangeVersion.major === version.major;\n    // ^0.1, ^0.2\n    else if (rangeVersion.minor >= 1)\n      return version.major === 0 && rangeVersion.minor === version.minor;\n    // ^0.0.x falls down to exact match below\n  }\n\n  // check fuzzy range (we can assume rangeVersion.minor exists, due to behaviour switch)\n  if (range.fuzzy)\n    return version.major === rangeVersion.major && version.minor <= rangeVersion.minor;\n\n  // exact match\n  // eg 001.002.003 matches 1.2.3\n  return !rangeVersion.pre && rangeVersion.major === version.major && rangeVersion.minor === version.minor && rangeVersion.patch === version.patch;\n}\n\n/*\n * semver       - is this a semver range\n * fuzzy        - is this a fuzzy range\n * version      - the parsed version object\n */\nfunction parseRange(range) {\n  var rangeObj = {};\n\n  ((rangeObj.semver = range.startsWith('^')) ||\n      (rangeObj.fuzzy = range.startsWith('~'))\n  ) && (range = range.substr(1)); // jshint ignore:line\n\n  var rangeVersion = rangeObj.version = parseSemver(range);\n\n  if (rangeVersion.tag)\n    return rangeObj;\n\n  // 0, 0.1 behave like ~0, ~0.1\n  if (!rangeObj.fuzzy && !rangeObj.semver && (isNaN(rangeVersion.minor) || isNaN(rangeVersion.patch)))\n    rangeObj.fuzzy = true;\n\n  // ~1, ~0 behave like ^1, ^0\n  if (rangeObj.fuzzy && isNaN(rangeVersion.minor)) {\n    rangeObj.semver = true;\n    rangeObj.fuzzy = false;\n  }\n\n  // ^0.0 behaves like ~0.0\n  if (rangeObj.semver && rangeObj.major === 0 && !isNaN(rangeVersion.minor) && isNaN(rangeVersion.patch)) {\n    rangeObj.semver = false;\n    rangeObj.fuzzy = true;\n  }\n\n  return rangeObj;\n}\n\nexports.semverRegEx = semverRegEx;\n\nexports.compare = function(v1, v2) {\n  return semverCompareParsed(parseSemver(v1), parseSemver(v2));\n};\n\nexports.match = function match(range, version) {\n  // supported range types:\n  // 0.2, 1, ~1.2.3, ^1.2.3, ^0.4.3-alpha.1\n  if (range === '' || range === '*')\n    return true;\n  return matchParsed(parseRange(range), parseSemver(version));\n};\n\nexports.matchUnstable = function match(range, version) {\n  // supported range types:\n  // 0.2, 1, ~1.2.3, ^1.2.3, ^0.4.3-alpha.1\n  if (range === '' || range === '*')\n    return true;\n  return matchParsed(parseRange(range), parseSemver(version), true);\n};\n","/home/travis/build/npmtest/node-npmtest-jspm/node_modules/jspm/lib/build.js":"/*\n *   Copyright 2014-2015 Guy Bedford (http://guybedford.com)\n *\n *   Licensed under the Apache License, Version 2.0 (the \"License\");\n *   you may not use this file except in compliance with the License.\n *   You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n *   Unless required by applicable law or agreed to in writing, software\n *   distributed under the License is distributed on an \"AS IS\" BASIS,\n *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *   See the License for the specific language governing permissions and\n *   limitations under the License.\n */\nrequire('core-js/es6/string');\n\nvar Promise = require('rsvp').Promise;\nvar asp = require('rsvp').denodeify;\nvar fs = require('graceful-fs');\nvar glob = require('glob');\nvar rimraf = require('rimraf');\nvar path = require('path');\nvar minimatch = require('minimatch');\n\nvar build = module.exports;\n\nexports.buildPackage = function(dir, pjson, isCDN) {\n  return build.filterIgnoreAndFiles(dir, pjson.ignore, pjson.files)\n\n  // check if directories.dist exists\n  // if so collapse and do nothing further\n  .then(function() {\n    if (!pjson.directories || !pjson.directories.dist)\n      return;\n\n    return asp(fs.stat)(path.resolve(dir, pjson.directories.dist))\n    .then(function(stats) {\n      return stats && stats.isDirectory();\n    }, function() {\n      return false;\n    })\n    .then(function(dist) {\n      if (dist)\n        return build.collapseLibDir(dir, pjson.directories.dist).then(function() { return true; });\n    });\n  })\n\n  // check if directories.lib exists, if so collapse\n  .then(function(dist) {\n    if (dist)\n      return true;\n\n    if (!pjson.directories || !pjson.directories.lib)\n      return;\n\n    return asp(fs.stat)(path.resolve(dir, pjson.directories.lib))\n    .then(function(stats) {\n      return stats && stats.isDirectory();\n    }, function() {\n      return false;\n    })\n    .then(function(dist) {\n      if (dist)\n        return build.collapseLibDir(dir, pjson.directories.lib);\n    });\n  })\n\n  // finally, build\n  .then(function(hasDist) {\n    if (pjson.format || pjson.shim || pjson.buildConfig || (pjson.registry && pjson.dependencies) || pjson.map)\n      return build.compileDir(dir, {\n        format: pjson.format,\n        shim: pjson.shim,\n        dependencies: pjson.dependencies, // dependencies already parsed into jspm-compatible\n        removeJSExtensions: pjson.useJSExtensions,\n        map: pjson.map,\n        transpile: !hasDist && pjson.buildConfig && pjson.buildConfig.transpile,\n        minify: isCDN, // && !hasDist && pjson.buildConfig && (pjson.buildConfig.uglify || pjson.buildConfig.minify)\n        alwaysIncludeFormat: isCDN\n      });\n  });\n};\n\nexports.filterIgnoreAndFiles = function(dir, ignore, files) {\n  if (!ignore && !files)\n    return Promise.resolve();\n\n  return asp(glob)(dir + path.sep + '**' + path.sep + '*', {dot: true})\n  .then(function(allFiles) {\n    var removeFiles = [];\n\n    allFiles.forEach(function(file) {\n      var fileName = path.relative(dir, file).replace(/\\\\/g, '/');\n\n      // if files, remove all files except those in the files list\n      if (files && !files.some(function(keepFile) {\n        if (keepFile.startsWith('./'))\n          keepFile = keepFile.substr(2);\n        else if (keepFile.startsWith('/'))\n          keepFile = keepFile.substr(1);\n\n        // this file is in a keep dir, or a keep file, don't exclude\n        if (inDir(fileName, keepFile, false) || minimatch(fileName, keepFile))\n          return true;\n      }))\n        return removeFiles.push(fileName);\n\n      // if ignore, ensure removed\n      if (ignore && ignore.some(function(ignoreFile) {\n        if (ignoreFile.startsWith('./'))\n          ignoreFile = ignoreFile.substr(2);\n        else if (ignoreFile.startsWith('/'))\n          ignoreFile = ignoreFile.substr(1);\n        // this file is in an ignore dir or an ignore file, ignore\n        if (inDir(fileName, ignoreFile, false) || minimatch(fileName, ignoreFile))\n          return true;\n      }))\n        removeFiles.push(fileName);\n    });\n\n    return removeFiles.map(function(removeFile) {\n      return path.resolve(dir, removeFile);\n    })\n    // do removal of files in reverse order so that directories get removed properly\n    .reverse()\n    .reduce(function(removePromise, resolvedFile) {\n      return removePromise.then(function() {\n        return asp(fs.unlink)(resolvedFile)\n        .catch(function(e) {\n          if (e.code === 'ENOENT')\n            return;\n          if (e.code === 'EISDIR' || e.code === 'EPERM')\n            return asp(fs.rmdir)(resolvedFile)\n            .catch(function(e) {\n              if (e.code === 'ENOTEMPTY')\n                return;\n              throw e;\n            });\n          throw e;\n        });\n      });\n    }, Promise.resolve());\n  });\n};\n\nexports.collapseLibDir = function(dir, subDir) {\n  if (subDir.endsWith('/'))\n    subDir = subDir.substr(0, subDir.length - 1);\n\n  var tmpDir = path.resolve(dir, '..', '.tmp-' + dir.split(path.sep).pop());\n\n  // move subDir to tmpDir\n  return asp(fs.rename)(path.normalize(dir + path.sep + subDir), tmpDir)\n\n  // remove everything in dir\n  .then(function() {\n    return asp(rimraf)(dir);\n  })\n\n  // move subDir to dir\n  .then(function() {\n    return asp(fs.rename)(tmpDir, dir);\n  });\n};\n\nfunction inDir(fileName, dir, sep) {\n  return fileName.substr(0, dir.length) === dir && (sep === false || fileName.substr(dir.length - 1, 1) === path.sep);\n}\n\nfunction matchWithWildcard(matches, name) {\n  var curMatch;\n  var curMatchLength;\n\n  main:\n  for (var p in matches) {\n    if (!matches.hasOwnProperty(p))\n      continue;\n\n    var matchParts = p.split('/');\n    var nameParts = name.split('/');\n    if (matchParts.length !== nameParts.length)\n      continue;\n\n    var match;\n\n    for (var i = 0; i < matchParts.length; i++) {\n      // do wildcard matching on individual parts if necessary\n      if (matchParts[i].includes('*')) {\n        if (!(match = nameParts[i].match(new RegExp(matchParts[i].replace(/([^*\\w])/g, '\\\\$1').replace(/(\\*)/g, '(.*)')))))\n          continue main;\n      }\n      else if (nameParts[i] !== matchParts[i])\n        continue main;\n    }\n\n    // least wildcards in match wins\n    if (p.length >= curMatchLength)\n      continue;\n\n    curMatch = p;\n    curMatchLength = matchParts.length;\n  }\n  return curMatch;\n}\n\n// return the number of prefix parts (separated by '/') matching the name\n// eg prefixMatchLength('jquery/some/thing', 'jquery') -> 1\nfunction prefixMatchLength(name, prefix) {\n  var prefixParts = prefix.split('/');\n  var nameParts = name.split('/');\n  if (prefixParts.length > nameParts.length)\n    return 0;\n  for (var i = 0; i < prefixParts.length; i++)\n    if (nameParts[i] !== prefixParts[i])\n      return 0;\n  return prefixParts.length;\n}\n\n// while doing map, we also remove \".js\" extensions where necessary\nfunction applyMap(_name, map, baseFile, removeJSExtensions) {\n  var name = _name, pluginName;\n\n  if (name.includes('!')) {\n    pluginName = name.substr(name.indexOf('!') + 1);\n    name = name.substr(0, name.length - pluginName.length - 1);\n    pluginName = pluginName || name.substr(name.lastIndexOf('.') + 1);\n    pluginName = applyMap(pluginName, map, baseFile, false) || pluginName;\n  }\n\n\n  if (removeJSExtensions) {\n    if (name.startsWith('./') || name.split('/').length > 1) {\n      if (name.endsWith('.js'))\n        name = name.substr(0, name.length - 3);\n    }\n  }\n\n  for (var m in map) {\n    if (!map.hasOwnProperty(m))\n      continue;\n\n    var matchLength = prefixMatchLength(name, m);\n    if (!matchLength)\n      continue;\n\n    var subPath = name.split('/').splice(matchLength).join('/');\n\n    var toMap = map[m];\n\n    if (typeof toMap != 'string')\n      continue;\n\n    if (toMap.startsWith('./')) {\n      // add .js in case of matching directory name\n      toMap = path.relative(path.dirname(baseFile), toMap.substr(2) + '.js').replace(/\\\\/g, '/');\n      if (!toMap.startsWith('.'))\n        toMap = './' + toMap;\n      // remove .js\n      toMap = toMap.substr(0, toMap.length - 3);\n    }\n\n    return toMap + (subPath ? '/' + subPath : '') + (pluginName ? '!' + pluginName : '');\n  }\n\n  if (pluginName)\n    name += '!' + pluginName;\n\n  if (name !== _name)\n    return name;\n}\n\n// NB keep these up to date with SystemJS\nvar esmRegEx = /(^\\s*|[}\\);\\n]\\s*)(import\\s+(['\"]|(\\*\\s+as\\s+)?[^\"'\\(\\)\\n;]+\\s+from\\s+['\"]|\\{)|export\\s+\\*\\s+from\\s+[\"']|export\\s+(\\{|default|function|class|var|const|let|async\\s+function))/;\nvar esmDepRegEx = /(^|\\}|\\s)(from|import)\\s*(\"([^\"]+)\"|'([^']+)')/g;\nvar amdRegEx = /(?:^|[^$_a-zA-Z\\xA0-\\uFFFF.])define\\s*\\(\\s*(\"[^\"]+\"\\s*,\\s*|'[^']+'\\s*,\\s*)?\\s*(\\[(\\s*((\"[^\"]+\"|'[^']+')\\s*,|\\/\\/.*\\r?\\n|\\/\\*(.|\\s)*?\\*\\/))*(\\s*(\"[^\"]+\"|'[^']+')\\s*,?)?(\\s*(\\/\\/.*\\r?\\n|\\/\\*(.|\\s)*?\\*\\/))*\\s*\\]|function\\s*|{|[_$a-zA-Z\\xA0-\\uFFFF][_$a-zA-Z0-9\\xA0-\\uFFFF]*\\))/;\nvar amdDefineRegEx = /(?:^|[^$_a-zA-Z\\xA0-\\uFFFF.])define\\s*\\(\\s*(\"[^\"]+\"\\s*,|'[^']+'\\s*,\\s*)?(\\[(\\s*(\"[^\"]+\"|'[^']+')\\s*,)*(\\s*(\"[^\"]+\"|'[^']+')\\s*)?\\])?/g;\nvar cjsRequireRegEx = /(?:^\\uFEFF?|[^$_a-zA-Z\\xA0-\\uFFFF.\"'])require\\s*\\(\\s*(\"[^\"\\\\]*(?:\\\\.[^\"\\\\]*)*\"|'[^'\\\\]*(?:\\\\.[^'\\\\]*)*')\\s*\\)/g;\nvar cjsExportsRegEx = /(?:^\\uFEFF?|[^$_a-zA-Z\\xA0-\\uFFFF.]|module\\.)(exports\\s*\\[['\"]|\\exports\\s*\\.)|(?:^\\uFEFF?|[^$_a-zA-Z\\xA0-\\uFFFF.])module\\.exports\\s*\\=/;\n\nvar registerRegEx = /System\\.register/;\n\nvar metaRegEx = /^(\\s*\\/\\*.*\\*\\/|\\s*\\/\\/[^\\n]*|\\s*\"[^\"]+\"\\s*;?|\\s*'[^']+'\\s*;?)+/;\nvar metaPartRegEx = /\\/\\*.*\\*\\/|\\/\\/[^\\n]*|\"[^\"]+\"\\s*;?|'[^']+'\\s*;?/g;\n\n  // var commentRegEx = /(\\/\\*([\\s\\S]*?)\\*\\/|([^:]|^)\\/\\/(.*)$)/mg;\nvar initialCommentRegEx = /^\\s*(\\/\\*|\\/\\/)/;\n\nfunction detectFormat(source) {\n  // first checkout if we have format meta\n  var meta = source.match(metaRegEx);\n  var metadata = {};\n  if (meta) {\n    var metaParts = meta[0].match(metaPartRegEx);\n    for (var i = 0; i < metaParts.length; i++) {\n      var len = metaParts[i].length;\n\n      var firstChar = metaParts[i].substr(0, 1);\n      if (metaParts[i].endsWith(';'))\n        len--;\n\n      if (firstChar !== '\"' && firstChar !== '\\'')\n        continue;\n\n      var metaString = metaParts[i].substr(1, metaParts[i].length - 3);\n\n      var metaName = metaString.substr(0, metaString.indexOf(' '));\n      if (metaName) {\n        var metaValue = metaString.substr(metaName.length + 1, metaString.length - metaName.length - 1);\n\n        if (metadata[metaName] instanceof Array)\n          metadata[metaName].push(metaValue);\n        else\n          metadata[metaName] = metaValue;\n      }\n    }\n  }\n\n  if (metadata.format)\n    return { format: metadata.format, meta: true };\n\n  cjsExportsRegEx.lastIndex = 0;\n  cjsRequireRegEx.lastIndex = 0;\n  if (source.match(esmRegEx))\n    return { format: 'esm' };\n\n  if (source.match(registerRegEx))\n    return { format: 'register' };\n\n  if (source.match(amdRegEx))\n    return { format: 'amd' };\n\n  if (cjsRequireRegEx.exec(source) || cjsExportsRegEx.exec(source))\n    return { format: 'cjs' };\n\n  return { format: 'global' };\n}\nexports.detectFormat = detectFormat;\n\n/*\n  options.format\n  options.shim\n  options.dependencies\n  options.map\n  options.removeJSExtensions\n  options.transpile\n  options.minify\n  options.sourceURLBase\n  options.alwaysIncludeFormat\n*/\nexports.compileDir = function(dir, options) {\n  dir = path.resolve(dir);\n\n  options.sourceURLBase = options.sourceURLBase || '';\n\n  // store a list of compile errors\n  var compileErrors = '';\n\n  // create the map config\n  // convert jspm options.dependencies into a requirable form\n  // and combine them into a new map object\n  var map = {}, optionsMap, optionsDependencies;\n  if (options.map)\n    optionsMap = options.map;\n    for (var m in optionsMap)\n      if (optionsMap.hasOwnProperty(m))\n        map[m] = optionsMap[m];\n\n  if (options.dependencies) {\n    optionsDependencies = options.dependencies;\n    for (var d in optionsDependencies) {\n      if (!optionsDependencies.hasOwnProperty(d))\n        continue;\n      // custom map overrides dependency map\n      if (map[d])\n        continue;\n\n      var curDep = optionsDependencies[d];\n      if (curDep.includes(':') || curDep.includes('@'))\n        map[d] = curDep;\n\n      else if (curDep && curDep !== '*')\n        map[d] = d + '@' + curDep;\n      else\n        map[d] = d;\n    }\n  }\n\n  var nl = '\\n';\n\n  // glob each \".js\" file\n  return asp(glob)(dir + path.sep + '**' + path.sep + '*.js')\n\n  .then(function(files) {\n\n    return Promise.all(files.map(function(file) {\n\n      var changed = false;\n\n      var sourceMap;\n\n      var format;\n      if (options.format && typeof options.format === 'string')\n        format = options.format.toLowerCase();\n\n      var relFile = path.relative(dir, file);\n      var relModule = relFile.substr(0, relFile.length - 3).replace(/\\\\/g, '/');\n\n      // first check if a symlink\n      return asp(fs.lstat)(file)\n      .then(function(stats) {\n        if (stats.isSymbolicLink())\n          return;\n\n        return asp(fs.readFile)(file)\n        .then(function(source) {\n          source += '';\n\n          return Promise.resolve()\n          // add shim config if necessary\n          .then(function() {\n            if (!options.shim)\n              return;\n\n            var match;\n\n            if (!(match = matchWithWildcard(options.shim, relModule)))\n              return;\n\n            var curShim = options.shim[match];\n            if (curShim instanceof Array)\n              curShim = { deps: curShim };\n\n            // NB backwards-compatible with shim.imports\n            curShim.deps = curShim.deps || curShim.imports;\n\n            if (typeof curShim.deps === 'string')\n              curShim.deps = [curShim.deps];\n\n            var depStr = '\"format global\";' + nl;\n            if (curShim.deps)\n              for (var i = 0; i < curShim.deps.length; i++)\n                depStr += '\"deps ' + curShim.deps[i] + '\";' + nl;\n\n            if (curShim.exports)\n              depStr += '\"exports ' + curShim.exports + '\";' + nl;\n\n            changed = true;\n            source = depStr + source;\n\n            return true;\n          })\n\n          // add any format hint if provided\n          // only add format hint if detection would fail\n          // also set the format here if not set\n          // NB all regexs should apply after removing comments\n          // also ideally format injection should be post-minification\n          // in case of minification quirks\n          .then(function(shimmed) {\n            // don't add format if already shimmed!\n            if (shimmed)\n              return;\n\n            var detected = detectFormat(source);\n\n            // don't rewrite meta\n            if (detected.meta) {\n              format = detected.format;\n              return;\n            }\n\n            if (format == 'es6')\n              format = 'esm';\n\n            if (options.alwaysIncludeFormat || !format || detected.format !== format) {\n              changed = true;\n              source = '\"format ' + (format || detected.format) + '\";' + nl + source;\n            }\n\n            if (!format)\n              format = detected.format;\n          })\n\n          // apply map config\n          .then(function() {\n            // ES Module\n            if (format === 'esm') {\n              source = source.replace(esmDepRegEx, function(statement, start, type, str, singleString, doubleString) {\n                var name = singleString || doubleString;\n                var mapped = applyMap(name, map, relFile, options.removeJSExtensions);\n\n                if (!mapped)\n                  return statement;\n\n                changed = true;\n                return statement.replace(new RegExp('\"' + name + '\"|\\'' + name + '\\'', 'g'), '\\'' + mapped + '\\'');\n              });\n            }\n\n            // AMD\n            else if (format === 'amd') {\n              amdDefineRegEx.lastIndex = 0;\n              var defineStatement = amdDefineRegEx.exec(source);\n              if (defineStatement) {\n                if (!defineStatement[2])\n                  return;\n\n                var depArray = eval(defineStatement[2]);\n                depArray = depArray.map(function(name) {\n                  var mapped = applyMap(name, map, relFile, options.removeJSExtensions);\n\n                  if (!mapped)\n                    return name;\n\n                  changed = true;\n                  return mapped;\n                });\n\n                if (changed)\n                  source = source.replace(defineStatement[2], JSON.stringify(depArray));\n              }\n            }\n\n            // CommonJS\n            else if (format === 'cjs') {\n              source = source.replace(cjsRequireRegEx, function(statement, singleString, doubleString) {\n                var name = singleString || doubleString;\n                name = name.substr(1, name.length - 2);\n                var mapped = applyMap(name, map, relFile, options.removeJSExtensions);\n\n                if (!mapped)\n                  return statement;\n\n                changed = true;\n                return statement.replace(new RegExp('\"' + name + '\"|\\'' + name + '\\'', 'g'), '\\'' + mapped + '\\'');\n              });\n            }\n\n            // Global? (including shim?)\n            // else {\n            // }\n          })\n\n          // if changed, save these meta-updates into the original file\n          .then(function() {\n\n            // ensure there is a comment at the beginning of the file\n            // this is necessary to protect the source map when wrapping\n            if (!source.match(initialCommentRegEx)) {\n              source = '\\/* *\\/ \\n' + source;\n              changed = true;\n            }\n\n            if (changed)\n              return asp(fs.writeFile)(file, source);\n          })\n\n          // transpile\n          .then(function() {\n            if (!options.transpile)\n              return;\n\n            var traceur = require('traceur');\n\n            traceur.options.sourceMaps = true;\n            traceur.options.modules = 'instantiate';\n\n            try {\n              var compiler = new traceur.Compiler({\n                moduleName: '',\n                modules: 'instantiate'\n              });\n\n              source = compiler.compile(source, relFile, path.basename(relFile.replace(/\\.js$/, '.src.js')));\n              sourceMap = compiler.getSourceMap();\n            }\n            catch(e) {\n              // an error in one compiled file doesn't stop all compilation\n\n              if (!e.stack)\n                compileErrors +=  + '\\n';\n              else\n                compileErrors += e.stack + '\\n' + relFile + ': Unable to transpile ES Module\\n';\n            }\n          })\n\n          // minify\n          .then(function() {\n            if (!options.minify)\n              return;\n\n            var uglify = require('uglify-js');\n\n            try {\n              var ast = uglify.parse(source, { filename: path.basename(relFile.replace(/\\.js$/, '.src.js')) });\n\n              ast.figure_out_scope();\n\n              ast = ast.transform(uglify.Compressor({\n                warnings: false,\n                evaluate: false\n              }));\n\n              ast.figure_out_scope();\n              ast.compute_char_frequency();\n              ast.mangle_names({\n                except: ['require']\n              });\n\n              var source_map = uglify.SourceMap({\n                file: path.basename(relFile),\n                orig: sourceMap\n              });\n\n              source = ast.print_to_string({\n                ascii_only: true, // for some reason non-ascii broke esprima\n                comments: function(node, comment) {\n                  return comment.line === 1 && comment.col === 0;\n                },\n                source_map: source_map\n              });\n              sourceMap = source_map.toString();\n            }\n            catch(e) {\n              // an error in one compiled file doesn't stop all compilation\n              compileErrors += relFile + ': Unable to minify file\\n';\n            }\n          })\n\n          // finally, if compiled, rename to the new file with source maps\n          .then(function() {\n            if (!options.minify && !options.transpile)\n              return;\n\n            // rename the original with meta changes to .src.js\n            return asp(fs.rename)(file, file.replace(/\\.js$/, '.src.js'))\n\n            // write .js as the current source, with a source map comment\n            .then(function() {\n              return asp(fs.writeFile)(file, source + '\\n//# sourceMappingURL=' + relFile.split('/').pop() + '.map');\n            })\n\n            // write the source map to .js.map\n            .then(function() {\n              return asp(fs.writeFile)(file + '.map', sourceMap);\n            });\n          });\n        }, function(e) {\n          if (e.code === 'EISDIR')\n            return;\n          else\n            throw e;\n        });\n      }, function(e) {\n        // rethrow an error that wasn't a file read error\n        if (e.code === 'EISDIR')\n          return;\n        else\n          throw e;\n      });\n    }));\n  })\n\n  // output of compile promise is any compile errors\n  .then(function() {\n    return compileErrors;\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-jspm/node_modules/jspm/lib/registry.js":"/*\n *   Copyright 2014-2015 Guy Bedford (http://guybedford.com)\n *\n *   Licensed under the Apache License, Version 2.0 (the \"License\");\n *   you may not use this file except in compliance with the License.\n *   You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n *   Unless required by applicable law or agreed to in writing, software\n *   distributed under the License is distributed on an \"AS IS\" BASIS,\n *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *   See the License for the specific language governing permissions and\n *   limitations under the License.\n */\nvar fs = require('graceful-fs');\nvar path = require('path');\nvar config = require('./config');\nvar globalConfig = require('./global-config');\nvar ui = require('./ui');\nvar dextend = require('./common').dextend;\nvar Promise = require('rsvp').Promise;\n\n/*\n  Registry API\n  See https://github.com/jspm/jspm-cli/wiki/Registry-API for the spec\n*/\nvar registryClasses = {};\n\nprocess.on('exit', function() {\n  // dispose all loaded registries\n  // allows for saving cache state using sync fs\n  for (var e in registryClasses) {\n    if (registryClasses[e].dispose)\n      registryClasses[e].dispose();\n  }\n});\n\nvar registryHooks = ['locate', 'lookup', 'download', 'getPackageConfig', 'processPackageConfig', 'build', 'getOverride'];\n\nexports.load = function(registry) {\n  if (registryClasses[registry])\n    return registryClasses[registry];\n\n  try {\n    // ensure the tmpDir exists\n    var tmpDir = path.resolve(config.HOME, '.jspm', registry + '-cache');\n    if (!fs.existsSync(tmpDir))\n      fs.mkdirSync(tmpDir);\n\n    var options = dextend({\n      timeouts: {\n        lookup: 60,\n        download: 300,\n        build: 120\n      },\n      tmpDir: tmpDir,\n      apiVersion: '1.6'\n    }, globalConfig.config.registries[registry] || {});\n\n    options.name = registry;\n    if (globalConfig.config.strictSSL === false || globalConfig.config.strictSSL == 'false')\n      options.strictSSL = false;\n\n    if (!options.handler)\n      throw 'Registry %' + registry + '% not found.';\n\n    var RegistryClass = require(options.handler);\n    var registryPackageJSON = require(options.handler + '/package.json');\n    var versionString = registryPackageJSON.name + '@' + registryPackageJSON.version.split('.').splice(0, 2).join('.');\n    options.versionString = versionString;\n\n    var registryInstance = registryClasses[registry] = new RegistryClass(options, ui);\n    registryInstance.constructor = RegistryClass;\n\n    var timeoutLookup = options.timeouts.lookup * 1000;\n    var timeoutDownload = options.timeouts.download * 1000;\n    var timeoutBuild = options.timeouts.build * 1000;\n\n    registryInstance.versionString = registryInstance.versionString || versionString;\n\n    var maxRetries = globalConfig.config.maxRetries || 3;\n\n    // patch the calls to apply timeout and retry logic\n    registryHooks.forEach(function(hook) {\n      if (!registryInstance[hook])\n        return;\n\n      var runHook = registryInstance[hook];\n      registryInstance[hook] = function() {\n        var self = this;\n        var args = arguments;\n        var retries = 0;\n        var timeout;\n        if (hook == 'download')\n          timeout = timeoutDownload;\n        else if (hook == 'build')\n          timeout = timeoutBuild;\n        else\n          timeout = timeoutLookup;\n\n        return new Promise(function(resolve, reject) {\n\n          function tryHook() {\n            var active = true;\n\n            var timer = setTimeout(function() {\n              active = false;\n              checkRetry();\n            }, timeout);\n\n            // in case registry is being reconfigured, chain on a promise\n            // which delivers the registry to use, when it is ready\n            (self.reconfigPromise_ || Promise.resolve(self))\n            .then(function(endpoint) {\n              self = endpoint;\n              return runHook.apply(self, args);\n            })\n            .then(function(result) {\n              clearTimeout(timer);\n              if (active)\n                resolve(result);\n            }, function(err) {\n              clearTimeout(timer);\n              if (!active)\n                return;\n              active = false;\n              return checkConfigure(err) || checkRetry(err);\n            });\n          }\n\n          /* When err.config is set, that indicates config credentials are somehow the cause.\n           * Call the configure hook and reinstantiate the registry with new config */\n          function checkConfigure(err) {\n            if (err && err.config && !self.triedConfig) {\n              // Place promise chain on existing instance, to block subsequent hooks.\n              // Also print warning for only for first such error, if multiple in a batch\n              if (!self.reconfigPromise_) {\n                ui.log('warn', err.message);\n\n                self.reconfigPromise_ = exports.configure(registry)\n                .then(function() {\n                  // replace registered instance\n                  delete registryClasses[registry];\n                  var instance = exports.load(registry);\n                  instance.triedConfig = true;\n                  return instance;\n                });\n              }\n\n              tryHook();\n              return true;\n            }\n          }\n\n          function checkRetry(err) {\n            // don't retry build or processPackageConfig\n            if (hook === 'build' || hook === 'processPackageConfig')\n              retries = maxRetries;\n\n            retries++;\n            var retriable = !err || err.retriable;\n            var retry = retriable && retries <= maxRetries;\n\n            var msg = (err ? 'Error' : 'Timed out') + ' on ' + hook +\n               (typeof args[0] === 'string' ? ' for `' + registry + ':' + args[0] + '`' : '') +\n               (retry ? ', retrying (' + retries + ').' : '') +\n\n               (!err ? '\\nTo increase the timeout run %jspm config registries.' + registry + '.timeouts.' + (hook == 'download' || hook == 'build' ? hook : 'lookup') + ' ' + timeout / 1000 * 2 + '%' : '') +\n               (err ? '\\n' + (!err.hideStack && err.stack || err) : '');\n            ui.log('warn', msg);\n            if (retry)\n              return tryHook();\n            else\n              return reject();\n          }\n\n          tryHook();\n        });\n      };\n    });\n\n    return registryInstance;\n  }\n  catch(e) {\n    ui.log('err', !e.hideStack && e.stack || e);\n    throw 'Unable to load registry %' + registry + '%';\n  }\n};\n\nexports.configure = function(registry) {\n  var registryConfig = globalConfig.config.registries[registry] || {},\n      RegistryClass;\n\n  if (!registryConfig.handler)\n    throw 'Registry %' + registry + '% not found.';\n\n  var handler = registryConfig.handler;\n  delete registryConfig.handler;\n\n  try {\n    RegistryClass = require(handler);\n  }\n  catch(e) {\n    throw 'Registry handler `' + handler + '` not installed.';\n  }\n\n  registryConfig.name = registry;\n  registryConfig.strictSSL = globalConfig.config.strictSSL;\n\n  return Promise.resolve(RegistryClass.configure && RegistryClass.configure(registryConfig, ui) || registryConfig)\n  .then(function(_config) {\n    delete _config.name;\n    delete _config.strictSSL;\n    _config.handler = handler;\n    globalConfig.config.registries[registry] = _config;\n  })\n  .then(function() {\n    globalConfig.save();\n  });\n};\n\n// jspm registry create mycompany jspm-github\n// creates a custom registry based on the given handler\nexports.create = function(name, handler, override) {\n\n  // handle override prompts etc\n  if (!override && globalConfig.config.registries[name]) {\n    if (globalConfig.config.registries[name].handler === handler)\n      return ui.confirm('Registry %' + name + '% already exists. Do you want to reconfigure it now?')\n      .then(function(configure) {\n        if (configure)\n          return Promise.resolve(exports.configure(name))\n          .then(function() {\n            ui.log('ok', 'Registry %' + name + '% configured successfully.');\n            return false;\n          });\n        else\n          return false;\n      });\n    else\n      return ui.confirm('Registry %' + name + '% already exists, but based on `' + globalConfig.config.registries[name].handler + '`. Are you sure you want to override it?')\n      .then(function(override) {\n        if (override)\n          return Promise.resolve(exports.create(name, handler, true));\n        return false;\n      });\n  }\n\n  var registryConfig = globalConfig.config.registries[name] = globalConfig.config.registries[name] || {};\n  registryConfig.handler = handler;\n\n  // load the registry and configure it\n  return exports.configure(name);\n};\n","/home/travis/build/npmtest/node-npmtest-jspm/node_modules/jspm/lib/global-config.js":"/*\n *   Copyright 2014-2015 Guy Bedford (http://guybedford.com)\n *\n *   Licensed under the Apache License, Version 2.0 (the \"License\");\n *   you may not use this file except in compliance with the License.\n *   You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n *   Unless required by applicable law or agreed to in writing, software\n *   distributed under the License is distributed on an \"AS IS\" BASIS,\n *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *   See the License for the specific language governing permissions and\n *   limitations under the License.\n */\n\nvar ui = require('./ui');\nvar fs = require('graceful-fs');\nvar path = require('path');\nvar HOME = require('./config').HOME;\nvar lockFile = require('proper-lockfile');\nvar dprepend = require('./common').dprepend;\nvar readJSONSync = require('./common').readJSONSync;\nvar stringify = require('./common').stringify;\n\n// global config - automatically created and loaded on startup\nexports.registries = [];\nvar globalConfigFile = HOME + path.sep + '.jspm' + path.sep + 'config';\n\n// old windows HOME migration\n// can deprecate with jspm 0.15.3\nif (process.env.USERPROFILE && HOME !== process.env.USERPROFILE && !fs.existsSync(path.join(HOME, '.jspm')) && fs.existsSync(path.join(process.env.USERPROFILE, '.jspm'))) {\n  var OLD_HOME = process.env.USERPROFILE;\n  var from = path.join(OLD_HOME, '.jspm');\n  var to = path.join(HOME, '.jspm');\n  ui.log('info', 'Migrating global jspm folder from `' + from + '` to `' + to + '`...');\n  try {\n    ui.log('info', 'Copying configuration...');\n    var oldConfig = fs.readFileSync(path.resolve(from, 'config'));\n    fs.mkdirSync(to);\n    fs.writeFileSync(path.resolve(to, 'config'), oldConfig);\n    ui.log('ok', 'Migration successful. Note that linked packages will need to be relinked.');\n  }\n  catch (e) {\n    ui.log('err', 'Error migrating to new jspm folder\\n' + (e && e.stack || e));\n  }\n}\n\n// Begin file lock\nlock();\n\n// after loading, we'll dprepend all defaults to `exports.config` in this `try` block\nexports.config = readJSONSync(globalConfigFile);\n\n// NB can deprecate with jspm 0.14\nif (!exports.config.defaultRegistry && exports.config.registry)\n  exports.config.defaultRegistry = exports.config.registry;\nif (!exports.config.registries && exports.config.endpoints)\n  exports.config.registries = exports.config.endpoints;\n\n// NB add this to deprecate 0.14\n// delete exports.config.registry;\n// delete exports.config.endpoints;\n\n// config upgrade paths\n// NB can deprecate with jspm < 10\nif (exports.config.github) {\n  dprepend(exports.config.registries.github, exports.config.github);\n  delete exports.config.github;\n}\n\n// populate default registry configuration\ndprepend(exports.config, {\n  defaultTranspiler: 'babel',\n  defaultRegistry: 'jspm',\n  strictSSL: true,\n  registries: {\n    github: {\n      handler: 'jspm-github',\n      remote: 'https://github.jspm.io'\n    },\n    npm: {\n      handler: 'jspm-npm',\n      remote: 'https://npm.jspm.io'\n    },\n    jspm: {\n      handler: 'jspm-registry',\n      remote: 'https://registry.jspm.io'\n    }\n  }\n});\n\ntry{\n  if (HOME)\n    save();\n} catch(ex) {\n  console.error('Unable to initialize JSPM home configuration folder!');\n}\n// end file lock\nunlock();\n\nfunction save() {\n  try {\n    fs.mkdirSync(HOME + path.sep + '.jspm');\n  }\n  catch (e) {\n    if (e.code !== 'EEXIST')\n      throw 'Unable to create jspm system folder\\n' + e.stack;\n  }\n  try {\n    lock();\n    var existing = readJSONSync(globalConfigFile);\n    // only write to a new file if the local changes are different\n    if (JSON.stringify(existing) != JSON.stringify(exports.config)) {\n      fs.writeFileSync(globalConfigFile, stringify(exports.config));\n    }\n  }\n  catch (e) {\n    throw 'Unable to write global configuration file\\n' + e.stack;\n  }\n  finally {\n    unlock();\n  }\n}\nexports.save = save;\n\nexports.set = function(name, val) {\n  var nameParts = name.split('.');\n\n  var config = exports.config;\n  var part;\n  while (nameParts.length > 1) {\n    part = nameParts.shift();\n    config[part] = typeof config[part] === 'object' ? config[part] : {};\n    config = config[part];\n  }\n  if (val !== undefined) {\n    config[nameParts[0]] = val;\n  }\n  else {\n    // If no value is specified, then remove property from config\n    delete config[nameParts[0]];\n  }\n\n  save();\n};\n\nvar _unlock;\nfunction lock() {\n  if (!_unlock) {\n    try {\n      _unlock = lockFile.lockSync(globalConfigFile, {\n        retries: {\n          retries: 10,\n          minTimeout: 20,\n          maxTimeout: 300,\n          randomize: true\n        },\n        realpath: false\n      });\n    } catch (e) {\n      if (e.code === 'ELOCKED')\n        throw 'Unable to lock global config file %' + globalConfigFile + '%, not overwriting';\n    }\n  }\n}\nfunction unlock() {\n  if (_unlock) {\n    _unlock();\n    _unlock = undefined;\n  }\n}\n// Map SIGINT & SIGTERM to process exit\n// so that lockfile removes the lockfile automatically\nprocess\n  .once('SIGINT', function () {\n    process.exit(1);\n  })\n  .once('SIGTERM', function () {\n    process.exit(1);\n  });\n","/home/travis/build/npmtest/node-npmtest-jspm/node_modules/jspm/lib/config/package-name.js":"/*\n *   Copyright 2014-2015 Guy Bedford (http://guybedford.com)\n *\n *   Licensed under the Apache License, Version 2.0 (the \"License\");\n *   you may not use this file except in compliance with the License.\n *   You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n *   Unless required by applicable law or agreed to in writing, software\n *   distributed under the License is distributed on an \"AS IS\" BASIS,\n *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *   See the License for the specific language governing permissions and\n *   limitations under the License.\n */\n\n/*\n  Parse a package name into registry:package@version\n\n  name: 'github:jquery/jquery',\n  exactName: 'github:jquery/jquery@2.0.3',\n  exactPackage: 'jquery/jquery@2.0.3',\n\n  registry: 'github',\n  package: 'jquery/jquery',\n  version: '2.0.3'\n*/\nfunction Package(name, escape) {\n  this.exactName = name;\n\n  if (name.indexOf(':') !== -1)\n    this.registry = name.split(':')[0];\n\n  var pkg = this.registry ? name.substr(this.registry.length + 1) : name;\n\n  var versionIndex = pkg.lastIndexOf('@');\n  var version = '';\n\n  if (versionIndex !== -1 && versionIndex !== 0) {\n    version = pkg.substr(versionIndex + 1);\n    pkg = pkg.substr(0, versionIndex);\n  }\n\n  if (escape && version)\n    version = version.replace(/[\\/%]/g, function(symbol) {\n      return encodeURIComponent(symbol);\n    });\n\n  this.package = pkg;\n\n  this.name = (this.registry ? this.registry + ':' : '') + this.package;\n\n  this.setVersion(version);\n}\n\nPackage.prototype.setVersion = function(version) {\n  if (version === '*')\n    version = '';\n  this.version = version;\n  var v = this.version ? '@' + this.version : '';\n  this.exactPackage = this.package + v;\n  this.exactName = this.name + v;\n  return this;\n};\n\nPackage.prototype.setRegistry = function(registry) {\n  if (this.registry)\n    throw 'Endpoint already set.';\n  this.registry = registry;\n  this.exactName = registry + ':' + this.exactName;\n  this.name = registry + ':' + this.name;\n  return this;\n};\n\nPackage.prototype.copy = function() {\n  return new Package(this.exactName);\n};\n\nvar path = require('path');\nvar config = require('../config');\nPackage.prototype.getPath = function() {\n  return path.resolve(config.pjson.packages, this.registry, this.exactPackage);\n};\n\nPackage.prototype.write = function() {\n  return this.exactName;\n};\n\nmodule.exports = Package;\n","/home/travis/build/npmtest/node-npmtest-jspm/node_modules/jspm/lib/config/loader.js":"/*\n *   Copyright 2014-2015 Guy Bedford (http://guybedford.com)\n *\n *   Licensed under the Apache License, Version 2.0 (the \"License\");\n *   you may not use this file except in compliance with the License.\n *   You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n *   Unless required by applicable law or agreed to in writing, software\n *   distributed under the License is distributed on an \"AS IS\" BASIS,\n *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *   See the License for the specific language governing permissions and\n *   limitations under the License.\n */\n\nvar registry = require('../registry');\nvar config = require('../config');\nvar extend = require('../common').extend;\nvar hasProperties = require('../common').hasProperties;\nvar fs = require('graceful-fs');\nvar asp = require('rsvp').denodeify;\nvar path = require('path');\nvar PackageName = require('./package-name');\nvar alphabetize = require('../common').alphabetize;\nvar stringify = require('../common').stringify;\nvar ui = require('../ui');\nvar extractObj = require('./utils').extractObj;\nvar globalConfig = require('../global-config');\n\n/*\n * Loader Configuration Class\n *\n * baseURL\n * defaultJSExtensions\n * registries\n * transpiler\n * babelOptions\n * traceurOptions\n * typescriptOptions\n *\n * paths\n * bundles\n * depCache\n *\n * baseMap\n * depMap\n * versions\n *\n */\n// and registry is a path rule ending in ':*'\nvar registryRegEx = /\\:\\*$/;\nfunction Config(fileName) {\n  this.__fileName = fileName;\n}\nConfig.prototype.read = function(prompts, sync) {\n  if (this.__read)\n    throw 'Config already read';\n  this.__read = true;\n\n  var self = this;\n  var source;\n  try {\n    source = fs.readFileSync(this.__fileName);\n  }\n  catch(e) {\n    source = '';\n  }\n\n  var cfg = {};\n  var System = {\n    config: function(_cfg) {\n      for (var c in _cfg) {\n        if (!_cfg.hasOwnProperty(c))\n          continue;\n\n        var v = _cfg[c];\n        if (typeof v === 'object') {\n          cfg[c] = cfg[c] || {};\n          for (var p in v) {\n            if (!v.hasOwnProperty(p))\n              continue;\n            cfg[c][p] = v[p];\n          }\n        }\n        else\n          cfg[c] = v;\n      }\n    },\n    paths: {},\n    map: {},\n    versions: {}\n  };\n  eval(source.toString());\n\n  // allow declarative form too\n  var config = System.config;\n  delete System.config;\n  config(System);\n\n  self.__originalConfig = cfg;\n\n  self.baseURL = cfg.baseURL;\n\n  self.defaultJSExtensions = true;\n\n  if (cfg.transpiler === false)\n    cfg.transpiler = 'none';\n\n  // NB deprecate cfg.parser with 0.11.0\n  self.transpiler = cfg.transpiler || cfg.parser || globalConfig.config.defaultTranspiler;\n\n  // NB deprecate babel rename with 0.13\n  if (self.transpiler === '6to5')\n    self.transpiler = 'babel';\n\n  self.babelOptions = cfg.babelOptions || {};\n  self.traceurOptions = cfg.traceurOptions || {};\n  self.typescriptOptions = cfg.typescriptOptions || {};\n\n  // separate paths into registries and paths\n  self.registries = {};\n  self.paths = {};\n  for (var p in cfg.paths) {\n    if (p.match(registryRegEx)) {\n      var registryName = p.substr(0, p.length - 2);\n      var registryPath = new RegistryPath(registryName, cfg.paths[p]);\n      self.registries[registryName] = registryPath;\n      if (self.__local === undefined) {\n        if (registryPath.mode === 'local')\n          self.__local = true;\n        else\n          self.__local = false;\n      }\n    }\n    // deprecate *: *.js\n    else if (p === '*' && cfg.paths[p] === '*.js') {\n      delete cfg.paths[p];\n      continue;\n    }\n  }\n  self.paths = cfg.paths;\n\n  self.shim = cfg.shim;\n  self.bundles = cfg.bundles;\n  self.depCache = cfg.depCache;\n\n  // separate map into baseMap and depMap\n  self.baseMap = {};\n  self.depMap = {};\n  for (var d in cfg.map) {\n    if (typeof cfg.map[d] === 'string')\n      self.baseMap[d] = new PackageName(cfg.map[d]);\n    else {\n      var depMap = cfg.map[d];\n      self.depMap[d] = {};\n      for (var m in depMap)\n        if (depMap.hasOwnProperty(m)) {\n          self.depMap[d][m] = new PackageName(depMap[m]);\n        }\n    }\n  }\n\n  // ensure that everything in baseMap has a depMap, even if empty\n  var baseMap = self.baseMap, exactName;\n  for (var n in baseMap) {\n    if (baseMap.hasOwnProperty(n)) {\n      exactName = baseMap[n].exactName;\n      self.depMap[exactName] = self.depMap[exactName] || {};\n    }\n  }\n\n  self.versions = self.versions || {};\n  for (var v in cfg.versions) {\n    if (typeof cfg.versions[v] === 'string')\n      self.versions[v] = [cfg.versions[v]];\n    else\n      self.versions[v] = cfg.versions[v];\n  }\n\n  if (hasProperties(self.versions))\n    upgradeToExactVersionResolution(self);\n\n\n  if (!prompts)\n    return;\n\n  if (sync)\n    throw 'Configuration file has not been initialized. Run jspm init first.';\n\n  return ui.input('Enter client baseURL (public folder URL)', self.baseURL || '/')\n  .then(function(baseURL) {\n    self.baseURL = baseURL;\n\n    return ui.confirm('Do you wish to use a transpiler?', true);\n  })\n  .then(function(useTranspiler) {\n    if (!useTranspiler) {\n      self.transpiler = 'none';\n      return 'none';\n    }\n\n    return ui.input('Which ES6 transpiler would you like to use, %Babel%, %TypeScript% or %Traceur%?', self.transpiler);\n  })\n  .then(function(transpiler) {\n    transpiler = transpiler.toLowerCase();\n\n    if (transpiler !== 'babel' && transpiler !== 'traceur' && transpiler !== 'typescript' && transpiler !== 'none')\n      transpiler = globalConfig.config.defaultTranspiler;\n\n    self.transpiler = transpiler;\n    globalConfig.config.defaultTranspiler = transpiler;\n  });\n};\n\nConfig.prototype.ensureRegistry = function(registryName, remote) {\n  var registries = this.registries;\n\n  if (typeof remote === 'undefined') {\n    // detect the registry mode from the first registry\n    var registryKeys = Object.keys(registries);\n    if (registryKeys.length > 0) {\n      remote = registries[registryKeys[0]].mode === 'remote';\n    } else {\n      remote = false;\n    }\n  }\n\n  if (registries[registryName]) {\n    if (remote)\n      registries[registryName].setRemote();\n    else\n      registries[registryName].setLocal();\n    return;\n  }\n\n  var ep = registries[registryName] = new RegistryPath(registryName);\n  if (remote)\n    ep.setRemote();\n  else\n    ep.setLocal();\n};\n\n// return the loader configuration for a server loading use\nConfig.prototype.getConfig = function() {\n  var cfg = extend({}, this.__originalConfig);\n\n  // set all registry paths to be local paths\n  cfg.paths = extend({}, cfg.paths);\n  var registries = this.registries;\n  for (var e in registries) {\n    if (registries.hasOwnProperty(e))\n      cfg.paths[e + ':*'] = registries[e].local;\n  }\n  return cfg;\n};\n\n/*\n * RegistryPath object\n */\nvar jspmPackages;\nfunction RegistryPath(name, registryPath) {\n  jspmPackages = jspmPackages || path.relative(config.pjson.baseURL, config.pjson.packages).replace(/\\\\/g, '/');\n  var registryRemote = registry.load(name).remote;\n  this.remote = registryRemote + '/*';\n  this.local = jspmPackages + '/' + name + '/*';\n\n  this.mode = 'local';\n  if (registryPath === this.remote)\n    this.mode = 'remote';\n  this.path = registryPath;\n}\nRegistryPath.prototype.setLocal = function() {\n  this.path = this.local;\n  this.mode = 'local';\n};\nRegistryPath.prototype.setRemote = function() {\n  this.path = this.remote;\n  this.mode = 'remote';\n};\nRegistryPath.prototype.write = function() {\n  return this.path;\n};\n\nConfig.prototype.write = function() {\n  // extract over original config to keep initial values\n  var cfg = extractObj(this, this.__originalConfig),\n      cfgRegistries, cfgMap, cfgVersions;\n\n  cfgRegistries = cfg.registries;\n  for (var e in cfgRegistries) {\n    if (!cfgRegistries.hasOwnProperty(e))\n      continue;\n    var val = cfgRegistries[e];\n    delete cfgRegistries[e];\n    cfgRegistries[e + ':*'] = val;\n  }\n\n  extend(cfg.paths, alphabetize(cfg.registries));\n  delete cfg.registries;\n\n  cfg.baseMap = alphabetize(cfg.baseMap);\n  cfg.map = extend(cfg.baseMap, alphabetize(cfg.depMap));\n  delete cfg.baseMap;\n  delete cfg.depMap;\n\n  cfgMap = cfg.map;\n  for (var p in cfgMap) {\n    if (!cfgMap.hasOwnProperty(p))\n      continue;\n    var subMap = cfgMap[p];\n    if (typeof subMap === 'object') {\n      if (!hasProperties(subMap))\n        delete cfgMap[p];\n      else\n        cfgMap[p] = alphabetize(cfgMap[p]);\n    }\n  }\n\n  cfgVersions = cfg.versions;\n  for (var v in cfgVersions) {\n    if (!cfgVersions.hasOwnProperty(v))\n      continue;\n    var version = cfgVersions[v];\n    if (version.length === 1)\n      cfgVersions[v] = version[0];\n    if (version.length === 0)\n      delete cfgVersions[v];\n  }\n\n  var outConfig = {};\n\n  var meta = cfg.meta;\n  var depCache = cfg.depCache;\n  var map = cfg.map;\n  var versions = alphabetize(cfg.versions);\n\n  delete cfg.meta;\n  delete cfg.depCache;\n  delete cfg.map;\n  delete cfg.versions;\n\n  if (!hasProperties(cfg.babelOptions))\n    delete cfg.babelOptions;\n  if (!hasProperties(cfg.traceurOptions))\n    delete cfg.traceurOptions;\n  if (!hasProperties(cfg.typescriptOptions))\n    delete cfg.typescriptOptions;\n\n  if (cfg.bundles && !hasProperties(cfg.bundles))\n    delete cfg.bundles;\n\n  if (hasProperties(cfg))\n    extend(outConfig, cfg);\n\n  cfg.meta = meta;\n  cfg.depCache = depCache;\n  cfg.map = map;\n  cfg.versions = versions;\n\n  if (hasProperties(meta))\n    extend(outConfig, { meta: meta });\n\n  if (hasProperties(depCache))\n    extend(outConfig, { depCache: depCache });\n\n  if (hasProperties(map))\n    extend(outConfig, { map: map });\n\n  if (outConfig.transpiler === 'none')\n    outConfig.transpiler = false;\n\n  var configContent = stringify(outConfig)\n      // add a newline before \"meta\", \"depCache\", \"map\" blocks, removing quotes\n      .replace(new RegExp('^' + config.tab + '\"(meta|depCache|map|packages)\"', 'mg'), config.newLine + config.tab + '$1')\n      // remove quotes on first-level letter-based properties\n      .replace(new RegExp('^' + config.tab + '\"(\\\\w+)\"', 'mg'), config.tab + '$1');\n\n  return asp(fs.writeFile)(this.__fileName, 'System.config(' + configContent + ');' + config.newLine);\n};\nmodule.exports = Config;\n\n\n\n\n// --- can be removed after jspm@0.8 is fully deprecated --\nvar semver = require('../semver');\nfunction upgradeToExactVersionResolution(config) {\n  // run through depMap and baseMap, and assign exact version matches\n  Object.keys(config.baseMap).forEach(function(p) {\n    upgradeToExactVersionResolveRange(config.baseMap[p], config);\n  });\n\n  Object.keys(config.depMap).forEach(function(p) {\n    var curMap = config.depMap[p];\n    Object.keys(curMap).forEach(function(p) {\n      upgradeToExactVersionResolveRange(curMap[p], config);\n    });\n  });\n\n  config.versions = {};\n}\nfunction upgradeToExactVersionResolveRange(range, config) {\n  var versions = config.versions[range.name];\n  if (versions)\n  versions.sort(semver.compare).reverse().some(function(version) {\n    if (semver.match(range.version, version)) {\n      range.setVersion(version);\n      return true;\n    }\n  });\n}\n","/home/travis/build/npmtest/node-npmtest-jspm/node_modules/jspm/lib/config/utils.js":"// convert structured configuration into a plain object\n// by calling the .write() methods of structured classes\n// properties ending in _ are considered private\n// NB may be less convoluted just to make these explicit\nrequire('core-js/es6/string');\n\nmodule.exports.extractObj = function extractObj(obj, host) {\n  var out = {};\n  for (var p in obj) {\n    if (!obj.hasOwnProperty(p))\n      continue;\n    if (p.startsWith('__'))\n      continue;\n\n    var val = obj[p];\n    if (typeof val === 'string' || typeof val === 'number' || typeof val === 'boolean')\n      out[p] = val;\n    else if (typeof val === 'object') {\n      if (typeof val.write === 'function')\n        out[p] = val.write();\n      else if (val instanceof Array)\n        out[p] = val;\n      else\n        out[p] = extractObj(val, {});\n    }\n  }\n\n  for (var h in host)\n    if (host.hasOwnProperty(h) && !(h in out))\n      out[h] = host[h];\n\n  return out;\n};\n","/home/travis/build/npmtest/node-npmtest-jspm/node_modules/jspm/lib/link.js":"/*\n *   Copyright 2014-2015 Guy Bedford (http://guybedford.com)\n *\n *   Licensed under the Apache License, Version 2.0 (the \"License\");\n *   you may not use this file except in compliance with the License.\n *   You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n *   Unless required by applicable law or agreed to in writing, software\n *   distributed under the License is distributed on an \"AS IS\" BASIS,\n *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *   See the License for the specific language governing permissions and\n *   limitations under the License.\n */\nvar readJSON = require('./common').readJSON;\nvar package = require('./package');\nvar PackageName = require('./config/package-name');\nvar Promise = require('rsvp').Promise;\nvar asp = require('rsvp').denodeify;\nvar config = require('./config');\nvar ncp = require('ncp');\nvar path = require('path');\nvar ui = require('./ui');\nvar rimraf = require('rimraf');\nvar mkdirp = require('mkdirp');\nvar fs = require('graceful-fs');\n\nexports.link = function(name, dir, force) {\n  var pjson, linkDir, pkg;\n\n  return Promise.resolve()\n  .then(function() {\n    // try to get registry, package\n    return readJSON(path.resolve(dir, 'package.json'));\n  })\n  .then(function(_pjson) {\n    try {\n      pkg = new PackageName(name);\n    }\n    catch(e) {\n      pkg = {};\n    }\n\n    var packageName = pkg.package || _pjson.jspm && _pjson.jspm.name || _pjson.name;\n    var registry = pkg.registry || _pjson.jspm && _pjson.jspm.registry || _pjson.registry;\n    var version = pkg.version || _pjson.jspm && _pjson.jspm.version || _pjson.version;\n\n    if (!packageName)\n      throw 'Package name not specified.';\n    if (!registry)\n      throw 'Package registry not specified.';\n    if (!version)\n      throw 'Package version not specified.';\n\n    pkg = new PackageName(registry + ':' + packageName + '@' + version);\n\n    return package.derivePackageConfig(pkg, _pjson);\n  })\n  .then(function(_pjson) {\n    pjson = _pjson;\n\n    linkDir = path.resolve(config.HOME, '.jspm', 'linked', pkg.registry, pkg.exactPackage);\n    try {\n      if (fs.existsSync(linkDir)) {\n        return (force ? Promise.resolve(true) : ui.confirm('`' + pkg.exactName + '` is already linked, are you sure you want to override it (use -y to skip this prompt in future)?', true))\n        .then(function(override) {\n          return !override;\n        });\n      }\n    }\n    catch(e) {}\n  })\n  // clear the directory\n  .then(function(abort) {\n    if (abort)\n      return true;\n\n    return asp(rimraf)(linkDir)\n    // create it\n    .then(function() {\n      if (pjson.directories) {\n        if (pjson.directories.lib) {\n          dir = path.resolve(dir, pjson.directories.lib);\n          delete pjson.directories.lib;\n        }\n        if (pjson.directories.dist) {\n          dir = path.resolve(dir, pjson.directories.dist);\n          delete pjson.directories.dist;\n        }\n      }\n\n      return asp(mkdirp)(linkDir);\n    })\n    // copy the files to the local cache folder\n    .then(function() {\n      return asp(ncp)(dir, linkDir);\n    })\n    // run the jspm operations on the folder to process it\n    .then(function() {\n      return package.processPackage(pkg, linkDir, pjson, function() {});\n    })\n    .then(function() {\n      return asp(fs.writeFile)(path.resolve(linkDir, '.jspm.json'), JSON.stringify(pjson, null, 2));\n    });\n  })\n  .then(function(aborted) {\n    if (!aborted)\n      ui.log('ok', 'Package linked as `' + pkg.exactName + '`');\n    else\n      ui.log('info', 'Link operation aborted.');\n  }, function(err) {\n    ui.log('err', err.stack || err);\n  });\n};\n\nexports.lookup = function(pkg, edge) {\n  var packageParts = pkg.package.split('/');\n  var packagePart = packageParts.pop();\n  var linkFolder = path.resolve(config.HOME, '.jspm', 'linked', pkg.registry, packageParts.join('/'));\n\n  return asp(fs.readdir)(linkFolder)\n  .then(function(files) {\n    var versions = {};\n    var hasVersions;\n    files\n    .filter(function(file) {\n      return file.substr(0, file.lastIndexOf('@')) === packagePart;\n    })\n    .forEach(function(file) {\n      hasVersions = true;\n      versions[file.substr(file.lastIndexOf('@') + 1)] = { hash: 'hash' };\n    });\n\n    if (!hasVersions)\n      throw 'No version match found for `' + pkg.exactName + '`';\n\n    return function(version) {\n      var lookupObj = package.getVersionMatch(version, versions, {edge: edge});\n      if (!lookupObj)\n        return;\n\n      return pkg.copy().setVersion(lookupObj.version);\n    };\n  }, function(err) {\n    if (err.code === 'ENOENT')\n      throw 'No linked versions found for `' + pkg.name + '`';\n    throw err;\n  });\n};\n\nexports.symlink = function(pkg, downloadDeps) {\n  var linkDir = path.resolve(config.HOME, '.jspm', 'linked', pkg.registry, pkg.exactPackage);\n  var dir = path.resolve(config.pjson.packages, pkg.registry, pkg.exactPackage);\n  var pjson;\n\n  var fresh = false;\n\n  return asp(fs.readlink)(dir)\n  .then(function(linkString) {\n    if (linkString === linkDir)\n      return asp(fs.unlink)(dir);\n\n    return Promise.resolve(ui.confirm('`' + pkg.exactName + '` already linked, are you sure you want to link over it?', true))\n    .then(function(remove) {\n      if (!remove)\n        throw 'Aborted.';\n      return asp(fs.unlink)(dir);\n    });\n\n  }, function(err) {\n    if (err.code === 'ENOENT')\n      return;\n    if (err.code !== 'EINVAL' && err.code !== 'UNKNOWN')\n      throw err;\n\n    return Promise.resolve(ui.confirm('`' + pkg.exactName + '` already installed, are you sure you want to link over it?', true))\n    .then(function(remove) {\n      if (!remove)\n        throw 'Aborted.';\n      return asp(rimraf)(dir);\n    });\n  })\n  .then(function() {\n    return asp(mkdirp)(path.resolve(dir, '..'))\n    .then(function() {\n      return asp(fs.symlink)(linkDir, dir, 'junction');\n    })\n    .then(function() {\n      return readJSON(path.resolve(dir, '.jspm.json'));\n    })\n    .then(function(_pjson) {\n      pjson = config.derivePackageConfig(_pjson);\n      return package.createMain(pkg, pjson, dir);\n    });\n  })\n  .then(function() {\n    downloadDeps(package.processDeps(pjson.dependencies, pjson.registry));\n    return fresh;\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-jspm/node_modules/jspm/lib/bundle.js":"/*\n *   Copyright 2014-2015 Guy Bedford (http://guybedford.com)\n *\n *   Licensed under the Apache License, Version 2.0 (the \"License\");\n *   you may not use this file except in compliance with the License.\n *   You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n *   Unless required by applicable law or agreed to in writing, software\n *   distributed under the License is distributed on an \"AS IS\" BASIS,\n *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *   See the License for the specific language governing permissions and\n *   limitations under the License.\n */\nvar ui = require('./ui');\nvar path = require('path');\nvar config = require('./config');\nvar SystemJSBuilder = require('systemjs-builder');\nvar fs = require('fs');\nvar asp = require('rsvp').denodeify;\nvar extend = require('./common').extend;\nvar alphabetize = require('./common').alphabetize;\nvar toFileURL = require('./common').toFileURL;\n\n// jspm version of builder ignores config, baseURL arguments\n// just allows cfg object\nfunction Builder(_config) {\n  config.loadSync();\n  SystemJSBuilder.call(this, toFileURL(config.pjson.baseURL));\n\n  var cfg = config.loader.getConfig();\n\n  if (cfg.depCache)\n    delete cfg.depCache;\n  if (cfg.bundles)\n    delete cfg.bundles;\n  if (cfg.baseURL)\n    delete cfg.baseURL;\n\n  this.config(cfg, true);\n\n  if (typeof _config == 'object')\n    this.config(_config, true);\n}\nBuilder.prototype = Object.create(SystemJSBuilder.prototype);\n\n// extend build functions with jspm 0.16 compatibility options\nBuilder.prototype.bundle = function(expressionOrTree, outFile, opts) {\n  if (outFile && typeof outFile === 'object') {\n    opts = outFile;\n    outFile = undefined;\n  }\n\n  opts = opts || {};\n\n  if (outFile)\n    opts.outFile = outFile;\n\n  if (!('normalize' in opts))\n    opts.normalize = true;\n\n  if (!('lowResSourceMaps' in opts))\n    opts.lowResSourceMaps = true;\n\n  var self = this;\n\n  return SystemJSBuilder.prototype.bundle.call(this, expressionOrTree, opts)\n  .then(function(output) {\n\n    // Add the bundle to config if the inject flag was given\n    if (opts.injectConfig && opts.outFile) {\n      // NB deprecate\n      output.bundleName = output.bundleName || self.getCanonicalName(toFileURL(path.resolve(opts.outFile)));\n      var bundleName = output.bundleName;\n\n      if (!config.loader.bundles)\n        config.loader.bundles = {};\n      \n      config.loader.bundles[bundleName] = output.modules;\n      return config.save()\n      .then(function() {\n        return output;\n      });\n    }\n\n    return output;\n  });\n};\n\nBuilder.prototype.buildStatic = function(expressionOrTree, outFile, opts) {\n  if (outFile && typeof outFile === 'object') {\n    opts = outFile;\n    outFile = undefined;\n  }\n\n  opts = opts || {};\n\n  if (outFile)\n    opts.outFile = outFile;\n\n  if (!('format' in opts))\n    opts.format = 'global';\n\n  if (!('lowResSourceMaps' in opts))\n    opts.lowResSourceMaps = true;\n\n  return SystemJSBuilder.prototype.buildStatic.call(this, expressionOrTree, opts);\n};\n\n\nexports.Builder = Builder;\n\nexports.depCache = function(expression) {\n  var systemBuilder = new Builder();\n\n  expression = expression || config.loader.main;\n  \n  ui.log('info', 'Injecting the traced dependency tree for `' + expression + '`...');\n\n  return systemBuilder.trace(expression)\n  .then(function(tree) {\n    logTree(tree);\n    var depCache = config.loader.depCache || {};\n    extend(depCache, systemBuilder.getDepCache(tree));\n    config.loader.depCache = depCache;\n  })\n  .then(config.save)\n  .then(function() {\n    ui.log('ok', 'Dependency tree injected');\n  })\n  .catch(function(e) {\n    ui.log('err', e.stack || e);\n  });\n};\n\n// options.inject, options.sourceMaps, options.minify\nexports.bundle = function(moduleExpression, fileName, opts) {\n\n  var systemBuilder = new Builder();\n  \n  opts = opts || {};\n\n  opts.normalize = true;\n\n  fileName = fileName || path.resolve(config.pjson.baseURL, 'build.js');\n\n  return Promise.resolve()\n  .then(function() {\n\n    if (!opts.sourceMaps)\n      return removeExistingSourceMap(fileName);\n  })\n  .then(function() {\n    ui.log('info', 'Building the bundle tree for `' + moduleExpression + '`...');\n\n    return systemBuilder.trace(moduleExpression);\n  })\n  .then(function(buildTree) {\n    logTree(buildTree);\n    return systemBuilder.bundle(buildTree, fileName, opts);\n  })\n  .then(function(output) {\n    if (opts.injectConfig)\n      ui.log('ok', '`' + output.bundleName + '` added to config bundles.');\n\n    logBuild(path.relative(process.cwd(), fileName), opts);\n  })\n  .catch(function(e) {\n    ui.log('err', e.stack || e);\n    throw e;\n  });\n};\n\nexports.unbundle = function() {\n  return config.load()\n  .then(function() {\n    config.loader.bundles = {};\n    config.loader.depCache = {};\n    return config.save();\n  })\n  .then(function() {\n    ui.log('ok', 'Bundle configuration removed.');\n  });\n};\n\nfunction logBuild(outFile, opts) {\n  var resolution = opts.lowResSourceMaps ? '' : 'high-res ';\n  ui.log('ok', 'Built into `' + outFile + '`' +\n    (opts.sourceMaps ? ' with ' + resolution + 'source maps' : '') + ', ' +\n    (opts.minify ? '' : 'un') + 'minified' +\n    (opts.minify ? (opts.mangle ? ', ' : ', un') + 'mangled.' : '.'));\n}\n\n// options.minify, options.sourceMaps\nexports.bundleSFX = function(expression, fileName, opts) {\n  var systemBuilder = new Builder();\n  \n  opts = opts || {};\n\n  fileName = fileName || path.resolve(config.pjson.baseURL, 'build.js');\n\n  return Promise.resolve()\n  .then(function() {\n    if (!opts.sourceMaps)\n      return removeExistingSourceMap(fileName);\n  })\n  .then(function() {\n    ui.log('info', 'Building the single-file sfx bundle for `' + expression + '`...');\n\n    opts.format = opts.format || 'global';\n\n    return systemBuilder.buildStatic(expression, fileName, opts);\n  })\n  .then(function() {\n    logBuild(path.relative(process.cwd(), fileName), opts);\n  })\n  .catch(function(e) {\n    // catch sfx globals error to give a better error message\n    if (e.toString().indexOf('globalDeps option') != -1) {\n      var module = e.toString().match(/dependency \"([^\"]+)\"/);\n      ui.log('err', 'SFX exclusion \"' + module[1] + '\" needs a reference.\\nEither output an SFX module format like %--format amd% or map the module to an environment global via %--globals \"{\\'test.js\\': \\'test\\'}\"%.');\n      throw 'SFX Bundle input error';\n    }\n\n    ui.log('err', e.stack || e);\n    throw e;\n  });\n};\n\nfunction logTree(tree) {\n  ui.log('info', '');\n  tree = alphabetize(tree);\n  for (var name in tree) {\n    if (tree[name] && tree[name].metadata && tree[name].metadata.build !== false)\n      ui.log('info', '  `' + name + '`');\n  }\n  ui.log('info', '');\n}\n\nfunction removeExistingSourceMap(fileName) {\n  return asp(fs.unlink)(fileName + '.map')\n  .catch(function(e) {\n    if (e.code === 'ENOENT')\n      return;\n    throw e;\n  });\n}\n","/home/travis/build/npmtest/node-npmtest-jspm/node_modules/jspm/lib/core.js":"/*\n *   Copyright 2014-2015 Guy Bedford (http://guybedford.com)\n *\n *   Licensed under the Apache License, Version 2.0 (the \"License\");\n *   you may not use this file except in compliance with the License.\n *   You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n *   Unless required by applicable law or agreed to in writing, software\n *   distributed under the License is distributed on an \"AS IS\" BASIS,\n *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *   See the License for the specific language governing permissions and\n *   limitations under the License.\n */\nrequire('core-js/es6/string');\n\nvar Promise = require('rsvp').Promise;\nvar path = require('path');\nvar nodeSemver = require('semver');\nvar ui = require('./ui');\nvar config = require('./config');\nvar registry = require('./registry');\nvar build = require('./build');\nvar PackageName = require('./config/package-name');\nvar fs = require('graceful-fs');\nvar mkdirp = require('mkdirp');\nvar rimraf = require('rimraf');\nvar ncp = require('ncp');\nvar asp = require('rsvp').denodeify;\nvar System = require('systemjs');\nvar install = require('./install');\nvar globalConfig = require('./global-config');\nvar toFileURL = require('./common').toFileURL;\n\n\nvar core = module.exports;\n\n// we always download the latest semver compatible version\nvar systemVersion = require('../package.json').dependencies.systemjs;\n\nvar tPackages = {\n  'babel':           'npm:babel-core@^5.8.24',\n  'babel-runtime':   'npm:babel-runtime@^5.8.24',\n  'core-js':         'npm:core-js@^1.1.4',\n  'traceur':         'github:jmcriffey/bower-traceur@0.0.93',\n  'traceur-runtime': 'github:jmcriffey/bower-traceur-runtime@0.0.93',\n  'typescript':      'npm:typescript@^2.0.7'\n};\n\nexports.run = function(moduleName) {\n  return config.load()\n  .then(function() {\n    var cfg = config.loader.getConfig();\n    delete cfg.bundles;\n    cfg.baseURL = toFileURL(config.pjson.baseURL);\n    System.config(cfg);\n\n    return System.import(moduleName);\n  })\n  .catch(function(e) {\n    ui.log('err', e.stack || e);\n  });\n};\n\nexports.build = function() {\n  var saveConfig = false;\n\n  return config.load()\n  .then(function() {\n    if (config.pjson.buildConfig.transpileES6 === undefined) {\n      saveConfig = true;\n      return ui.confirm('Transpile ES6?', true);\n    }\n  })\n  .then(function(doTranspile) {\n    if (doTranspile)\n      config.pjson.buildConfig.transpileES6 = true;\n\n    if (!config.pjson.buildConfig || config.pjson.buildConfig.minify === undefined) {\n      saveConfig = true;\n      return ui.confirm('Minify?', true);\n    }\n  })\n  .then(function(doMinify) {\n    if (doMinify)\n      config.pjson.buildConfig.minify = true;\n\n    if (saveConfig)\n      return config.save();\n  })\n  .then(function() {\n    return asp(rimraf)(config.pjson.dist);\n  })\n  .then(function() {\n    return asp(ncp)(config.pjson.lib, config.pjson.dist);\n  })\n  .then(function() {\n    return build.compileDir(config.pjson.dist, {\n      format: config.pjson.format,\n      map: config.pjson.map,\n      transpile: config.pjson.buildConfig.transpileES6,\n      minify: config.pjson.buildConfig.minify,\n      removeJSExtensions: config.pjson.useJSExtensions\n    });\n  })\n  .then(function(compileErrors) {\n    if (compileErrors)\n      ui.log('warn', 'Compile Errors:\\n' + compileErrors);\n    else\n      ui.log('ok', 'Build Completed');\n  }, function(err) {\n    ui.log('err', err.stack || err);\n  });\n};\n\nexports.setMode = function(modes) {\n  if (!(modes instanceof Array))\n    modes = [modes];\n\n  var msg = '';\n\n  return config.load()\n  .then(function() {\n    if (modes.indexOf('local') === -1)\n      return true;\n\n    // set local\n    Object.keys(config.loader.registries).forEach(function(e) {\n      config.loader.registries[e].setLocal();\n    });\n\n    msg += 'Loader set to local library sources\\n';\n  })\n  .then(function(unmatched) {\n    if (modes.indexOf('remote') === -1)\n      return unmatched;\n\n    // set remote\n    Object.keys(config.loader.registries).forEach(function(e) {\n      config.loader.registries[e].setRemote();\n    });\n\n    msg += 'Loader set to CDN library sources\\n';\n  })\n  .then(function(unmatched) {\n    if (unmatched)\n      return ui.log('warn', 'Invalid mode');\n\n    return config.save()\n    .then(function() {\n      return msg;\n    });\n  });\n};\n\nexports.dlTranspiler = function(transpilerName, update) {\n  return config.load()\n  .then(function() {\n    var installObj = {};\n\n    transpilerName = transpilerName || config.loader.transpiler || globalConfig.config.defaultTranspiler;\n    \n    // skip download if not using a transpiler\n    if (transpilerName === 'none')\n      return;\n    \n    // read existing transpiler from package.json install\n    var target = !update && (config.pjson.devDependencies[transpilerName] || config.pjson.dependencies[transpilerName]);\n    if (target)\n      installObj[transpilerName] = target.exactName;\n    else\n      installObj[transpilerName] = transpilerName === 'traceur' ? tPackages.traceur : transpilerName === 'typescript' || transpilerName == 'ts' ? tPackages.typescript : tPackages.babel;\n    \n    // typescript does not have runtime library\n    if (transpilerName !== 'typescript') {\n      target = !update && (config.pjson.devDependencies[transpilerName + '-runtime'] || config.pjson.dependencies[transpilerName + '-runtime']);\n      if (target)\n        installObj[transpilerName + '-runtime'] = target.exactName;\n      else\n        installObj[transpilerName + '-runtime'] = transpilerName === 'traceur' ? tPackages['traceur-runtime'] : tPackages['babel-runtime'];\n    }\n    \n    if (transpilerName === 'babel') {\n      target = !update && (config.pjson.devDependencies['core-js'] || config.pjson.dependencies['core-js']);\n      if (target)\n        installObj['core-js'] = target.exactName;\n      else\n        installObj['core-js'] = tPackages['core-js'];\n    }\n    \n    // just do a quick install which checks basic existence\n    return install.install(installObj, { quick: !update, dev: true, summary: false });\n  })\n  .then(function() {\n    if (config.loader.transpiler !== transpilerName) {\n      config.loader.transpiler = transpilerName;\n      \n      if (transpilerName !== 'none')\n        ui.log('ok', 'ES6 transpiler set to %' + transpilerName + '%.');\n    }\n    if (transpilerName === 'babel')\n      if (!config.loader.babelOptions.optional)\n        config.loader.babelOptions.optional = ['runtime', 'optimisation.modules.system'];\n    return config.save();\n  });\n};\n\n// check and download module loader files\nexports.checkDlLoader = function(transpilerName) {\n  return config.load()\n  .then(function() {\n    transpilerName = transpilerName || config.loader.transpiler || globalConfig.config.defaultTranspiler;\n    var tPkgs = [];\n    if (transpilerName === 'traceur')\n      tPkgs = ['traceur', 'traceur-runtime'];\n    else if (transpilerName === 'babel')\n      tPkgs = ['babel', 'babel-runtime', 'core-js'];\n    else if (transpilerName === 'typescript')\n      tPkgs = ['typescript'];\n      \n    tPkgs.forEach(function(p) {\n      if (config.loader.baseMap[p])\n        if (config.loader.baseMap[p].version !== tPackages[p].split('@').pop() && !nodeSemver.satisfies(config.loader.baseMap[p].version, tPackages[p].split('@').pop()))\n          ui.log('warn', '`' + p + '@' + config.loader.baseMap[p].version + '` is unsupported for this version of jspm. Use %jspm dl-loader --latest% to update.');\n    });\n  })\n  .then(function() {\n    return asp(fs.readFile)(path.resolve(config.pjson.packages, '.loaderversions'));\n  })\n  .catch(function(err) {\n    if (err.code === 'ENOENT')\n      return '';\n    throw err;\n  })\n  .then(function(cacheVersions) {\n    if (cacheVersions.toString() !== systemVersion)\n      return exports.dlLoader(transpilerName);\n\n    // even if version file is fresh, still check files exist\n    return asp(fs.readdir)(config.pjson.packages)\n    .catch(function(err) {\n      if (err.code === 'ENOENT')\n        return [];\n      throw err;\n    })\n    .then(function(files) {\n      if (files.indexOf('system.js') === -1)\n        return exports.dlLoader(transpilerName);\n      return exports.dlTranspiler(transpilerName);\n    });\n  });\n};\n\n// mini registry API usage implementation\nvar loaderFilesCacheDir = path.join(config.HOME, '.jspm', 'loader-files');\n\nfunction dl(name, repo, version) {\n  var pkg = new PackageName(repo);\n  var endpoint = registry.load(pkg.registry);\n  var vMatch, vMatchLookup;\n  var dlDir = path.resolve(loaderFilesCacheDir, name);\n\n  return endpoint.lookup(pkg.package)\n  .then(function(lookup) {\n    if (!(nodeSemver.validRange(version)))\n      vMatch = version;\n    else\n      vMatch = Object.keys(lookup.versions)\n      .filter(nodeSemver.valid)\n      .sort(nodeSemver.compare).reverse()\n      .filter(function(v) {\n        return nodeSemver.satisfies(v, version);\n      })[0];\n\n    vMatchLookup = lookup.versions[vMatch];\n\n    return asp(fs.readFile)(path.resolve(dlDir, '.hash'))\n    .then(function(_hash) {\n      return _hash.toString() === vMatchLookup.hash;\n    }, function (e) {\n      if (e.code === 'ENOENT')\n        return;\n      throw e;\n    });\n  })\n  .then(function(cached) {\n    if (cached)\n      return;\n\n    return endpoint.download(pkg.package, vMatch, vMatchLookup.hash, vMatchLookup.meta, dlDir)\n    .then(function() {\n      return fs.writeFile(path.resolve(dlDir, '.hash'), vMatchLookup.hash);\n    });\n  })\n  .then(function() {\n    return vMatch;\n  });\n}\n\n// file copy implementation\nfunction cp(file, name, transform) {\n  return asp(fs.readFile)(path.resolve(loaderFilesCacheDir, file)).then(function(source) {\n    if (transform)\n      source = transform(source.toString());\n    ui.log('info', '  `' + name + '`');\n    return asp(fs.writeFile)(path.resolve(config.pjson.packages, name), source);\n  });\n}\n\nexports.dlLoader = function(transpilerName, unminified, edge, latest) {\n  ui.log('info', 'Looking up loader files...');\n  var min = unminified ? '.src' : '';\n\n  var using = {};\n\n  return config.load()\n  .then(function() {\n    return asp(mkdirp)(config.pjson.packages);\n  })\n  .then(function() {\n    // delete old versions\n    return asp(fs.readdir)(config.pjson.packages);\n  })\n  .then(function(files) {\n    return Promise.all(files.filter(function(file) {\n      return file.match(/^(system-csp|system-csp-production|system|es6-module-loader|traceur|babel|system-polyfills|typescript)/);\n    }).map(function(file) {\n      return asp(fs.unlink)(path.resolve(config.pjson.packages, file));\n    }));\n  })\n  .then(function() {\n    return dl('systemjs', 'github:systemjs/systemjs', !edge ? (!latest ? systemVersion : '^' + systemVersion) : 'master')\n    .then(function(version) {\n      using.system = version;\n      return Promise.all([\n        cp('systemjs/dist/system' + min + '.js', 'system.js'),\n        unminified || cp('systemjs/dist/system.src.js', 'system.src.js'),\n        unminified || cp('systemjs/dist/system.js.map', 'system.js.map'),\n        cp('systemjs/dist/system-csp-production' + min + '.js', 'system-csp-production.js'),\n        unminified || cp('systemjs/dist/system-csp-production.src.js', 'system-csp-production.src.js'),\n        unminified || cp('systemjs/dist/system-csp-production.js.map', 'system-csp-production.js.map'),\n        cp('systemjs/dist/system-polyfills' + min + '.js', 'system-polyfills.js'),\n        unminified || cp('systemjs/dist/system-polyfills.src.js', 'system-polyfills.src.js'),\n        unminified || cp('systemjs/dist/system-polyfills.js.map', 'system-polyfills.js.map')\n      ]);\n    });\n  })\n  .then(function() {\n    ui.log('info', '\\nUsing loader versions:');\n    ui.log('info', '  `systemjs@' + using.system + '`');\n\n    return asp(fs.writeFile)(path.resolve(config.pjson.packages, '.loaderversions'), systemVersion);\n  })\n  .then(function() {\n    return exports.dlTranspiler(transpilerName, latest);\n  })\n  .then(function() {\n    ui.log('ok', 'Loader files downloaded successfully');\n  }, function(err) {\n    ui.log('err', err);\n    ui.log('err', 'Error downloading loader files.');\n    throw err;\n  });\n};\n\nexports.init = function init(basePath, ask) {\n  if (basePath)\n    process.env.jspmConfigPath = path.resolve(basePath, 'package.json');\n  var relBase = path.relative(process.cwd(), path.dirname(process.env.jspmConfigPath));\n  if (relBase !== '')\n    ui.log('info', 'Initializing package at `' + relBase + '/`\\nUse %jspm init .% to intialize into the current folder.');\n  return config.load(ask)\n  .then(function() {\n    return config.save();\n  })\n  .then(function() {\n    ui.log('ok', 'Verified package.json at %' + path.relative(process.cwd(), config.pjsonPath) + '%\\nVerified config file at %' + path.relative(process.cwd(), config.pjson.configFile) + '%');\n  })\n  .then(function() {\n    return core.checkDlLoader();\n  })\n  .catch(function(err) {\n    ui.log('err', err && err.stack || err);\n  });\n};\n\nexports.cacheClear = function() {\n  var jspmDir = path.resolve(config.HOME, '.jspm'),\n      packagesCacheDir = path.join(jspmDir, 'packages'),\n      loaderCacheDir = path.join(jspmDir, 'loader-files'),\n      files, filesLength, fileName, i;\n\n  // Clear loader files\n  if (fs.existsSync(loaderCacheDir))\n    rimraf.sync(loaderCacheDir);\n  ui.log('ok', 'Loader file cache cleared.');\n\n  // Clear packages cache folder\n  if (fs.existsSync(packagesCacheDir))\n    rimraf.sync(packagesCacheDir);\n  ui.log('ok', 'Package cache cleared.');\n\n  // Clear registry cache folders\n  files = fs.readdirSync(jspmDir);\n  filesLength = files.length;\n  for (i = 0; i < filesLength; i++) {\n    fileName = files[i];\n    if (fileName.endsWith('-cache')) {\n      rimraf.sync(path.join(jspmDir, fileName));\n      ui.log('ok', '%' + fileName.substr(0, fileName.length - '-cache'.length) + '% cache cleared.');\n    }\n  }\n\n  ui.log('warn', 'All caches cleared.');\n  ui.log('info', 'Please post an issue if you suspect the cache isn\\'t invalidating properly.');\n  ui.log('info', '%jspm install -f% is equivalent to running a cache clear for that specific package tree.');\n};\n","/home/travis/build/npmtest/node-npmtest-jspm/node_modules/jspm/cli.js":"/*\n *   Copyright 2014-2015 Guy Bedford (http://guybedford.com)\n *\n *   Licensed under the Apache License, Version 2.0 (the \"License\");\n *   you may not use this file except in compliance with the License.\n *   You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n *   Unless required by applicable law or agreed to in writing, software\n *   distributed under the License is distributed on an \"AS IS\" BASIS,\n *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *   See the License for the specific language governing permissions and\n *   limitations under the License.\n */\n require('core-js/es6/string');\n\nvar ui = require('./lib/ui');\nvar chalk = require('chalk');\nvar config = require('./lib/config');\nvar globalConfig = require('./lib/global-config');\nvar core = require('./lib/core');\nvar bundle = require('./lib/bundle');\nvar registry = require('./lib/registry');\nvar install = require('./lib/install');\nvar fs = require('graceful-fs');\nvar Promise = require('rsvp').Promise;\n\nvar link = require('./lib/link');\n\nvar build = require('./lib/build');\n\nrequire('rsvp').on('error', function(reason) {\n  ui.log('warn', 'Unhandled promise rejection.\\n' + reason && reason.stack || reason || '' + '\\n');\n});\n\nprocess.on('uncaughtException', function(err) {\n  ui.log('err', err.stack || err);\n});\n\n/* jshint laxbreak: true */\n\n(function() {\n  function showHeader() {\n    ui.log('\\n'\n      + '  ' + chalk.bgWhite('      ') + '\\n'\n      + '  \\033[47m\\033[93m\\033[1m jspm \\033[0m\\033[90m  ' + chalk.grey('Browser Package Management') + '\\n'\n      + '  ' + chalk.bgWhite('      ') + '\\n'\n    );\n  }\n\n  function showInstructions() {\n    showHeader();\n    ui.log('\\n'\n      + 'jspm run main                      Run a jspm module in Node\\n'\n      + '\\n'\n      + 'jspm init [basepath] [--prompts]   Create / validate project configuration file\\n'\n      + '\\n'\n      + 'jspm install <name[=target]+> [--force skips cache] [--latest] [--dev]\\n'\n      + '  install jquery                   Install a package looked up in the jspm registry\\n'\n      + '  install react=npm:react          Install a package from a registry to latest\\n'\n      + '  install jquery=2 react           Install a package to a version or range\\n'\n      + '\\n'\n      + '  install                          Reproducible / shrinkwrap install package.json\\n'\n      + '\\n'\n      + '  install react --lock             Stable install, locking existing dependencies\\n'\n      + '\\n'\n      + '  install react=npm:react --edge   Install a package from a registry to latest unstable\\n'\n      + '\\n'\n      + '  install ts --dev                 Install a package as devDependency\\n'\n      + '\\n'\n      + '  install dep -o override.json     Install with the given custom override\\n'\n      + '  install dep -o \"{override json}\"   useful for testing package overrides\\n'\n      + '\\n'\n      + 'jspm update                        Update all packages from package.json\\n'\n      + 'jspm uninstall name                Uninstall a package and clean dependencies\\n'\n      + 'jspm clean                         Clear unused and orphaned dependencies\\n'\n      + '\\n'\n      + 'jspm inspect [--forks]             View all installed package versions\\n'\n      + 'jspm inspect npm:source-map        View the versions and ranges of a package\\n'\n      + '\\n'\n      + 'jspm inject <name[=target]> [--force] [--latest] [--lock] [-o]\\n'\n      + '  inject jquery                    Identical to install, but injects config\\n'\n      + '                                   only instead of downloading the package\\n'\n      + '\\n'\n      + 'jspm link registry:pkg@version     Link a local folder as an installable package\\n'\n      + 'jspm install --link registry:name  Install a linked package\\n'\n      + '\\n'\n      + 'jspm dl-loader [--edge --latest]   Download the browser loader files\\n'\n      + 'jspm dl-loader [babel|traceur|typescript]\\n'\n      + '\\n'\n      + 'jspm resolve --only registry:package@version\\n'\n      + '  resolve --only npm:jquery@2.1.1  Resolve all versions of a package to the given version\\n'\n      + '\\n'\n      + 'jspm setmode <mode>\\n'\n      + '  setmode local                    Switch to locally downloaded libraries\\n'\n      + '  setmode remote                   Switch to CDN external package sources\\n'\n      + '\\n'\n      + 'jspm bundle moduleA + module/b [outfile] [--minify] [--no-mangle] [--inject] [--skip-source-maps] [--source-map-contents]\\n'\n      + 'jspm bundle-sfx app/main [outfile] [--format <amd|cjs|global>] [--minify]\\n'\n      + 'jspm unbundle                      Remove injected bundle configuration\\n'\n      + 'jspm depcache moduleName           Stores dep cache in config for flat pipelining\\n'\n      + '\\n'\n      + 'jspm registry <command>            Manage registries\\n'\n      + '  registry config <name>           Configure an existing registry\\n'\n      + '  registry create <name> <pkg>     Create a new custom registry instance\\n'\n      // + '  registry export <registry-name>  Export an registry programatically\\n'\n      + '\\n'\n      + 'jspm config <option> <setting>     Configure jspm global options\\n'\n      + '                                   Stored in ~/.jspm/config\\n'\n      + '\\n'\n      + 'jspm cache-clear                   Clear global caches, not recommended\\n'\n      + '\\n'\n      + 'Global Flags\\n'\n      + ' --yes | -y                        Skip prompts / use default inputs\\n'\n      + ' --log <ok|warn|err>               Set log level\\n'\n      + ' --cwd [path]                      Set the working directory\\n'\n    );\n  }\n\n  function showVersion() {\n    // deprecate localJspm\n    ui.log(require('./package.json').version + '\\n'\n      + (process.env.globalJspm === 'true' || process.env.localJspm === 'false' ? 'Running against global jspm install.' : 'Running against local jspm install.'));\n  }\n\n  function dwalk(obj, visitor, pname) {\n    for (var p in obj) {\n      if (!obj.hasOwnProperty(p))\n        continue;\n      if (typeof obj[p] === 'object')\n        dwalk(obj[p], visitor, (pname ? pname + '.' : '') + p);\n      else\n        visitor((pname ? pname + '.' : '') + p, obj[p]);\n    }\n  }\n\n\n  // takes commandline args, space-separated\n  // flags is array of flag names\n  // optFlags is array of flags that have option values\n  // optFlags suck up arguments until next flag\n  // returns { [flag]: true / false, ..., [optFlag]: value, ..., args: [all non-flag args] }\n  function readOptions(inArgs, flags, optFlags) {\n    // output options object\n    var options = { args: [] };\n\n    flags = flags || [];\n    optFlags = optFlags || [];\n\n    var curOptionFlag;\n\n    function getFlagMatch(arg, flags) {\n      var index;\n\n      if (arg.startsWith('--')) {\n        index = flags.indexOf(arg.substr(2));\n        if (index !== -1)\n          return flags[index];\n      }\n      else if (arg.startsWith('-')) {\n        return flags.filter(function(f) {\n          return f.substr(0, 1) === arg.substr(1, 1);\n        })[0];\n      }\n    }\n\n    // de-sugar any coupled single-letter flags\n    // -abc -> -a -b -c\n    var args = [];\n    inArgs.forEach(function(arg) {\n      if (arg[0] == '-' && arg.length > 1 && arg[1] != '-') {\n        for (var i = 1; i < arg.length; i++)\n          args.push('-' + arg[i]);\n      }\n      else {\n        args.push(arg);\n      }\n    });\n\n    args.forEach(function(arg) {\n      var flag = getFlagMatch(arg, flags);\n      var optFlag = getFlagMatch(arg, optFlags);\n\n      // option flag -> suck up args\n      if (optFlag) {\n        curOptionFlag = optFlag;\n        options[curOptionFlag] = [];\n      }\n      // normal boolean flag\n      else if (flag) {\n        options[flag] = true;\n      }\n      // value argument\n      else {\n        if (curOptionFlag)\n          options[curOptionFlag].push(arg);\n        else\n          options.args.push(arg);\n      }\n    });\n\n    // flag values are strings\n    optFlags.forEach(function(flag) {\n      options[flag] = (options[flag] || []).join(' ');\n    });\n\n    return options;\n  }\n\n  // this will get a value in its true type from the CLI\n  function readValue(val) {\n    val = val.trim();\n    if (val === 'true' || val === 'false')\n      return eval(val);\n    else if (parseInt(val).toString() == val)\n      return parseInt(val);\n    else\n      return val;\n  }\n\n  // [].concat() to avoid mutating the given process.argv\n  var args = process.argv.slice(2),\n      options;\n\n  var logArgIndex = args.indexOf('--log');\n  if (logArgIndex > -1) {\n    ui.setLogLevel(args[logArgIndex + 1]);\n    args.splice(logArgIndex, 2);\n  }\n\n  var cwdArgIndex = args.indexOf('--cwd');\n  if (cwdArgIndex > -1) {\n    args.splice(cwdArgIndex, 2);\n  }\n\n  switch(args[0]) {\n    case 'run':\n      core.run(args[1]);\n      break;\n\n    case 'inject':\n      var inject = true;\n\n    case 'update':\n      var doUpdate = !inject;\n\n    case 'i':\n    case 'isntall':\n    case 'install':\n      options = readOptions(args, ['force', 'link', 'yes', 'lock', 'latest',\n                                   'unlink', 'quick', 'dev', 'edge', 'production'], ['override']);\n      options.inject = inject;\n      options.update = doUpdate;\n\n      args = options.args;\n\n      var depMap;\n      for (var i = 1; i < args.length; i++) {\n        depMap = depMap || {};\n        var name, target;\n        var arg = args[i];\n        name = arg.split('=')[0];\n        target = arg.split('=')[1];\n\n        if (!target) {\n          target = name;\n          if (name.indexOf(':') !== -1)\n            name = name.substr(name.indexOf(':') + 1);\n          if (name.indexOf('@') > 0)\n            name = name.substr(0, name.lastIndexOf('@'));\n        }\n\n        if (target.indexOf(':') === -1)\n          target = globalConfig.config.defaultRegistry + ':' + target;\n\n        depMap[name] = target || '';\n      }\n\n      var override = options.override;\n      if (override) {\n        if (!override.startsWith('{')) {\n          try {\n            options.override = fs.readFileSync(override);\n          }\n          catch(e) {\n            return ui.log('err', 'Unable to read override file %' + override + '%.');\n          }\n          try {\n            options.override = JSON.parse(options.override);\n          }\n          catch(e) {\n            return ui.log('err', 'Invalid JSON in override file %' + override + '%.');\n          }\n        }\n        else {\n          options.override = eval('(' + override + ')');\n        }\n      }\n\n      if (options.yes)\n        ui.useDefaults();\n\n      // jspm install with no arguments is locked\n      if (!depMap && !doUpdate)\n        options.lock = true;\n\n      // no install package -> install from package.json dependencies\n      (depMap ? install.install(depMap, options) : install.install(true, options))\n      .then(function() {\n        return core.checkDlLoader();\n      })\n      .then(function() {\n        return core.setMode(inject ? 'remote' : 'local');\n      })\n      .then(function() {\n        ui.log('');\n        ui.log('ok', 'Install complete.');\n        process.exit();\n      }, function(err) {\n        // something happened (cancel / err)\n        if (err)\n          ui.log('err', err.stack || err);\n        ui.log('warn', 'Installation changes not saved.');\n        process.exit(1);\n      });\n\n      break;\n\n    case 'r':\n    case 'remove':\n    case 'uninstall':\n      options = readOptions(args, ['yes']);\n\n      if (options.yes)\n        ui.useDefaults();\n\n      install.uninstall(options.args.splice(1))\n      .then(function() {\n        ui.log('');\n        ui.log('ok', 'Uninstall complete.');\n      }, function(err) {\n        ui.log('err', err.stack || err);\n        ui.log('warn', 'Uninstall changes not saved.');\n        process.exit(1);\n      });\n      break;\n\n    case 'resolve':\n      options = readOptions(args, null, ['only']);\n\n      if (!options.only)\n        return ui.log('warn', 'Use %jspm resolve --only registry:pkg@version%');\n\n      install.resolveOnly(options.only)\n      .catch(function(err) {\n        if (!err)\n          ui.log('err', 'Resolve operation not performed.');\n        else\n          ui.log('err', err.stack || err);\n        process.exit(1);\n      });\n      break;\n\n    case 'clean':\n      options = readOptions(args, ['yes']);\n      args = options.args;\n\n      if (options.yes)\n        ui.useDefaults();\n\n      install.clean()\n      .then(function() {\n        ui.log('');\n        ui.log('ok', 'Project cleaned successfully.');\n      }, function(err) {\n        ui.log('err', err.stack || err);\n        process.exit(1);\n      });\n      break;\n\n    case 'inspect':\n      options = readOptions(args, ['forks']);\n      args = options.args;\n\n      config.load()\n      .then(function() {\n        if (!args[1])\n          return install.showVersions(options.forks);\n        if (!args[1].includes(':'))\n          return ui.log('warn', 'Enter a full package name of the format `registry:repo`.');\n        return install.showInstallGraph(args[1]);\n      })\n      .catch(function(e) {\n        ui.log('err', e.stack || e);\n      });\n      break;\n\n    case 'init':\n      options = readOptions(args, ['yes', 'prompts']);\n      if (options.yes)\n        ui.useDefaults();\n      core.init(options.args[1], options.prompts);\n      break;\n\n    case 'dl-loader':\n      options = readOptions(args, ['source', 'latest', 'edge', 'yes', 'traceur', 'babel', 'typescript']);\n      if (options.yes)\n        ui.useDefaults();\n      core.dlLoader(options.args[1] || options.traceur && 'traceur' || options.babel && 'babel' || options.typescript && 'typescript', options.source, options.edge, options.latest);\n      break;\n\n    case 'setmode':\n      options = readOptions(args, ['yes']);\n      if (options.yes)\n        ui.useDefaults();\n      core.setMode(args.splice(1))\n      .then(function(msg) {\n        ui.log('ok', msg);\n      }, function(err) {\n        ui.log('err', err.stack || err);\n      });\n      break;\n\n    case 'depcache':\n      options = readOptions(args, ['yes']);\n      if (options.yes)\n        ui.useDefaults();\n      if (!args[1])\n        ui.log('warn', 'depCache requires a module name to trace.');\n      else\n        bundle.depCache(args[1]);\n      break;\n\n    case 'b':\n    case 'bundle-sfx':\n      var sfxBundle = true;\n\n    case 'bundle':\n      options = readOptions(args, ['inject', 'yes', 'skip-source-maps', 'minify',\n          'no-mangle', 'hires-source-maps', 'no-runtime', 'inline-source-maps', 'source-map-contents'], ['format', 'global-name', 'globals', 'global-defs']);\n\n      if (options.yes)\n        ui.useDefaults();\n      options.sourceMaps = !options['skip-source-maps'];\n      options.lowResSourceMaps = !options['hires-source-maps'];\n      options.mangle = !options['no-mangle'];\n      options.sourceMapContents = !!options['source-map-contents'];\n\n      if (options['inline-source-maps'])\n        options.sourceMaps = 'inline';\n\n      if (options['global-name'])\n        options.globalName = options['global-name'];\n\n      if (options.inject)\n        options.injectConfig = true;\n\n      options.format = options.format;\n\n      if (options.globals)\n        options.globalDeps = eval('(' + options.globals + ')');\n\n      if (options['global-defs'])\n        options.globalDefs = eval('(' + options['global-defs'] + ')');\n\n      var bArgs = options.args.splice(1);\n\n      if (bArgs.length === 0)\n        return ui.log('warn', 'You must provide at least one module as the starting point for bundling');\n\n      if (bArgs.length < 2) {\n        (sfxBundle ? bundle.bundleSFX : bundle.bundle)(bArgs[0], undefined, options)\n        .catch(function() {\n          process.exit(1);\n        });\n      }\n      else {\n        var secondLastArg = bArgs[bArgs.length - 2].trim();\n        var signChar = secondLastArg.substr(secondLastArg.length - 1, 1);\n        var expression = '';\n        var fileName;\n\n        // we can write: jspm bundle app + other\n        if (['+', '-'].indexOf(signChar) !== -1) {\n          expression = bArgs.join(' ');\n        }\n        // or we can write: jspm bundle app + other out.js\n        else {\n          expression = bArgs.splice(0, bArgs.length - 1).join(' ');\n          fileName = bArgs[bArgs.length - 1];\n        }\n        (sfxBundle ? bundle.bundleSFX : bundle.bundle)(expression, fileName, options)\n        .catch(function() {\n          process.exit(1);\n        });\n      }\n      break;\n\n    case 'unbundle':\n      bundle.unbundle()\n      .catch(function(e) {\n        ui.log('err', e.stack || e);\n        process.exit(1);\n      });\n      break;\n\n    case 'build':\n      options = readOptions(args, ['yes']);\n      if (options.yes)\n        ui.useDefaults();\n      core.build();\n      break;\n\n    case 'compile':\n      options = readOptions(args, ['transpile', 'minify', 'removeJSExtensions', 'yes'], ['map', 'format']);\n      if (options.yes)\n        ui.useDefaults();\n      if (options.map) {\n        var mapParts = options.map.split('=');\n        options.map = {};\n        options.map[mapParts[0]] = mapParts[1];\n      }\n\n      build.compileDir(args[1], options)\n      .then(function() {\n        ui.log('ok', 'Compilation complete');\n      }, function(e) {\n        ui.log('err', e.stack || e);\n      });\n      break;\n\n    case 'link':\n      options = readOptions(args, ['force', 'yes']);\n\n      if (options.yes)\n        ui.useDefaults();\n\n      args = options.args;\n\n      var linkname = args[2] || args[1] || '';\n      var linkpath = args[2] || '.';\n\n      link.link(linkname, linkpath, options.force);\n      break;\n\n    case 'registry':\n      options = readOptions(args, ['yes']);\n\n      if (options.yes)\n        ui.useDefaults();\n\n      var action = args[1];\n\n      if (action === 'config') {\n        if (!args[2])\n          return ui.log('warn', 'You must provide an registry name to configure.');\n        return Promise.resolve(registry.configure(args[2]))\n        .then(function() {\n          ui.log('ok', 'Registry %' + args[2] + '% configured successfully.');\n        }, function(err) {\n          ui.log('err', err.stack || err);\n        });\n      }\n      else if (action === 'create') {\n        if (!args[2])\n          return ui.log('warn', 'You must provide an registry name to create.');\n        if (!args[3])\n          return ui.log('warn', 'You must provide the registry module name to generate from.');\n        return Promise.resolve(registry.create(args[2], args[3]))\n        .then(function(created) {\n          if (created)\n            ui.log('ok', 'Enpoint %' + args[2] + '% created successfully.');\n        }, function(err) {\n          ui.log('err', err.stack || err);\n        });\n      }\n      else if (action === 'export') {\n        if (!args[2])\n          return ui.log('warn', 'You must provide an registry name to export.');\n        if (!globalConfig.config.registries[args[2]])\n          return ui.log('warn', 'Registry %' + args[2] + '% does not exist.');\n\n        var registryConfig = globalConfig.config.registries[args[2]];\n\n        dwalk(registryConfig, function(p, value) {\n          process.stdout.write('jspm config registries.' + args[2] + '.' + p + ' ' + value + '\\n');\n        });\n      }\n      else {\n        showInstructions();\n        ui.log('warn', 'Invalid registry argument %' + args[1] + '%.');\n      }\n      break;\n\n    case 'c':\n    case 'config':\n      var property = args[1];\n      var value = readValue(args.splice(2).join(' '));\n      globalConfig.set(property, value);\n      break;\n\n    case 'cc':\n    case 'cache-clear':\n      core.cacheClear();\n      break;\n\n    case '--help':\n    case '-h':\n      showInstructions();\n      break;\n\n    case '--version':\n    case '-v':\n      showVersion();\n      break;\n\n    default:\n      showInstructions();\n      if (args[0])\n        ui.log('warn', 'Invalid argument %' + args[0] + '%.');\n  }\n})();\n","/home/travis/build/npmtest/node-npmtest-jspm/node_modules/jspm/jspm.js":"#!/usr/bin/env node\n\n/*\n *   Copyright 2014-2015 Guy Bedford (http://guybedford.com)\n *\n *   Licensed under the Apache License, Version 2.0 (the \"License\");\n *   you may not use this file except in compliance with the License.\n *   You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n *   Unless required by applicable law or agreed to in writing, software\n *   distributed under the License is distributed on an \"AS IS\" BASIS,\n *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *   See the License for the specific language governing permissions and\n *   limitations under the License.\n */\n\nvar Liftoff = require('liftoff');\nvar path = require('path');\n\nvar jspmCLI = new Liftoff({\n  name: 'jspm',\n  configName: 'package',\n  extensions: {\n    '.json': null\n  }\n});\n\nvar args = process.argv.slice(2);\nvar cwdArgIndex = args.indexOf('--cwd');\nif (cwdArgIndex > -1) {\n  process.chdir(args[cwdArgIndex + 1]);\n}\n\njspmCLI.launch({ cwd: process.cwd() }, function(env) {\n  process.env.jspmConfigPath = env.configPath || '';\n  process.env.globalJspm = !env.modulePath;\n  if (env.modulePath)\n    require(path.resolve(env.modulePath, '../cli'));\n  else\n    require('./cli');\n});\n"}